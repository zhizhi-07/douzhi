/**
 * AIäº¤äº’é€»è¾‘Hookï¼ˆé‡æ„ç‰ˆï¼‰
 * ä½¿ç”¨æŒ‡ä»¤å¤„ç†å™¨æ¨¡å¼ï¼Œæ¶ˆé™¤é‡å¤ä»£ç 
 */

import { useState, useCallback, useRef, useEffect } from 'react'
import type { Character, Message } from '../../../types/chat'
import {
  getApiSettings,
  buildSystemPrompt,
  callAIApi,
  ChatApiError
} from '../../../utils/chatApi'
import {
  createMessage,
  getRecentMessages,
  parseAIMessages,
  convertToApiMessages
} from '../../../utils/messageUtils'
import { loadMessages } from '../../../utils/simpleMessageManager'
import { showNotification } from '../../../utils/simpleNotificationManager'
import { Logger } from '../../../utils/logger'
import { commandHandlers } from './commandHandlers'
import { blacklistManager } from '../../../utils/blacklistManager'
import { buildBlacklistPrompt, buildAIBlockedUserPrompt } from '../../../utils/prompts'
import { parseMomentsInteractions, executeMomentsInteractions } from '../../../utils/momentsInteractionParser'
import { parseAIMomentsPost, executeAIMomentsPost } from '../../../utils/aiMomentsPostParser'
import { triggerAIMomentsInteraction } from '../../../utils/momentsAI'
import { loadMoments } from '../../../utils/momentsManager'

export const useChatAI = (
  chatId: string,
  character: Character | null,
  messages: Message[],
  setMessages: (fn: (prev: Message[]) => Message[]) => void,
  setError: (error: string | null) => void,
  onVideoCallRequest?: () => void,
  refreshCharacter?: () => void
) => {
  const [isAiTyping, setIsAiTyping] = useState(false)
  const [isSending, setIsSending] = useState(false)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const sendTimeoutRef = useRef<number>()
  
  /**
   * æ»šåŠ¨åˆ°æ¶ˆæ¯åº•éƒ¨
   */
  const scrollToBottom = useCallback((instant = false) => {
    messagesEndRef.current?.scrollIntoView({ behavior: instant ? 'auto' : 'smooth' })
  }, [])
  
  /**
   * å‘é€ç”¨æˆ·æ¶ˆæ¯
   */
  const handleSend = useCallback((
    inputValue: string, 
    setInputValue: (val: string) => void,
    quotedMessage?: Message | null,
    clearQuote?: () => void
  ) => {
    // é˜²æ­¢é‡å¤å‘é€å’Œç©ºæ¶ˆæ¯
    if (!inputValue.trim() || isAiTyping || isSending) {
      return
    }
    
    // æ¸…é™¤ä¹‹å‰çš„å»¶è¿Ÿ
    if (sendTimeoutRef.current) {
      clearTimeout(sendTimeoutRef.current)
    }
    
    // è®¾ç½®å‘é€ä¸­çŠ¶æ€
    setIsSending(true)
    
    try {
      // æ£€æŸ¥AIæ˜¯å¦æ‹‰é»‘äº†ç”¨æˆ·
      const isUserBlocked = blacklistManager.isBlockedByMe(`character_${chatId}`, 'user')
      
      const userMessage: Message = {
        ...createMessage(inputValue, 'sent'),
        blockedByReceiver: isUserBlocked,
        quotedMessage: quotedMessage ? {
          id: quotedMessage.id,
          content: quotedMessage.content || quotedMessage.voiceText || quotedMessage.photoDescription || '...',
          senderName: quotedMessage.type === 'sent' ? 'æˆ‘' : (character?.realName || 'AI'),
          type: quotedMessage.type
        } : undefined
      }
      
      console.log('ğŸ“¤ å‘é€æ¶ˆæ¯:', inputValue.substring(0, 20), isUserBlocked ? '(è¢«AIæ‹‰é»‘)' : '')
      
      // æ›´æ–°ReactçŠ¶æ€ï¼ˆsetMessagesä¼šè‡ªåŠ¨ä¿å­˜åˆ°IndexedDBï¼‰
      setMessages(prev => [...prev, userMessage])
      setInputValue('')
      if (clearQuote) clearQuote()
      
      // å»¶è¿Ÿæ»šåŠ¨å’Œé‡ç½®å‘é€çŠ¶æ€
      sendTimeoutRef.current = setTimeout(() => {
        scrollToBottom(false)
        setIsSending(false)
      }, 100)
      
    } catch (error) {
      console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error)
      setIsSending(false)
    }
  }, [isAiTyping, isSending, character, setMessages, scrollToBottom])
  
  // æ¸…ç†å®šæ—¶å™¨
  useEffect(() => {
    return () => {
      if (sendTimeoutRef.current) {
        clearTimeout(sendTimeoutRef.current)
      }
    }
  }, [])

  /**
   * å¤„ç†AIå›å¤
   */
  const handleAIReply = useCallback(async () => {
    if (!character) {
      setError('è§’è‰²ä¸å­˜åœ¨')
      return
    }

    setIsAiTyping(true)
    setError(null)

    try {
      const settings = getApiSettings()
      if (!settings) {
        throw new ChatApiError('è¯·å…ˆé…ç½®API', 'NO_API_CONFIG')
      }

      // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‹‰é»‘äº†AI
      const isBlocked = blacklistManager.isBlockedByMe('user', chatId)
      console.log(`ğŸ” [æ‹‰é»‘æ£€æŸ¥] ç”¨æˆ·æ‹‰é»‘äº†AI: ${isBlocked}, chatId=${chatId}`)
      
      // æ£€æŸ¥AIæ˜¯å¦æ‹‰é»‘äº†ç”¨æˆ·
      const hasAIBlockedUser = blacklistManager.isBlockedByMe(`character_${chatId}`, 'user')
      console.log(`ğŸ” [æ‹‰é»‘æ£€æŸ¥] AIæ‹‰é»‘äº†ç”¨æˆ·: ${hasAIBlockedUser}`)
      
      let systemPrompt = await buildSystemPrompt(character)
      
      // å¦‚æœç”¨æˆ·æ‹‰é»‘äº†AIï¼Œåœ¨æœ€å‰é¢æ·»åŠ è­¦å‘Šæç¤ºï¼ˆç¡®ä¿AIä¼˜å…ˆçœ‹åˆ°ï¼‰
      if (isBlocked) {
        const blacklistWarning = buildBlacklistPrompt('ç”¨æˆ·')
        systemPrompt = blacklistWarning + '\n\n' + systemPrompt
        console.log('ğŸš¨ AIè¢«ç”¨æˆ·æ‹‰é»‘ï¼Œå·²åœ¨æç¤ºè¯æœ€å‰é¢æ·»åŠ è­¦å‘Š')
        console.log('è­¦å‘Šå†…å®¹ï¼š', blacklistWarning.substring(0, 200))
      }
      
      // å¦‚æœAIæ‹‰é»‘äº†ç”¨æˆ·ï¼Œæ·»åŠ çŠ¶æ€æé†’ï¼ˆè®©AIè®°ä½è¿™ä¸ªçŠ¶æ€ï¼‰
      if (hasAIBlockedUser) {
        const aiBlockedReminder = buildAIBlockedUserPrompt('ç”¨æˆ·')
        systemPrompt = aiBlockedReminder + '\n\n' + systemPrompt
        console.log('ğŸš« AIå·²æ‹‰é»‘ç”¨æˆ·ï¼Œå·²åœ¨æç¤ºè¯ä¸­æ·»åŠ çŠ¶æ€æé†’')
        console.log('æé†’å†…å®¹ï¼š', aiBlockedReminder.substring(0, 200))
      }
      
      // ä»localStorageè¯»å–æœ€æ–°æ¶ˆæ¯ï¼Œé¿å…é—­åŒ…é—®é¢˜
      const currentMessages = loadMessages(chatId)
      const recentMessages = getRecentMessages(currentMessages, chatId)
      const apiMessages = convertToApiMessages(recentMessages)

      Logger.log('å‘é€APIè¯·æ±‚', {
        messageCount: apiMessages.length,
        lastMessage: apiMessages[apiMessages.length - 1],
        isBlocked
      })
      
      // è¾“å‡ºåˆ°æ§åˆ¶å°ï¼šAIè¯»å–çš„æç¤ºè¯å’Œè®°å¿†
      console.group('ğŸ¤– [ç§ä¿¡èŠå¤©] AIè¯»å–çš„æç¤ºè¯å’Œè®°å¿†')
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')
      console.log('ğŸ“‹ ç³»ç»Ÿæç¤ºè¯ï¼š')
      console.log(systemPrompt)
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')
      console.log('ğŸ’­ èŠå¤©è®°å½•ï¼ˆå‘é€ç»™AIçš„æ¶ˆæ¯ï¼‰ï¼š')
      console.table(apiMessages.map((msg, i) => ({
        åºå·: i + 1,
        è§’è‰²: msg.role === 'user' ? 'ç”¨æˆ·' : (msg.role === 'assistant' ? 'AI' : 'ç³»ç»Ÿ'),
        å†…å®¹: msg.content ? msg.content.substring(0, 80) + (msg.content.length > 80 ? '...' : '') : ''
      })))
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')
      console.log('ğŸ“Š ç»Ÿè®¡ä¿¡æ¯ï¼š', {
        ç³»ç»Ÿæç¤ºè¯é•¿åº¦: systemPrompt.length,
        èŠå¤©è®°å½•æ¡æ•°: apiMessages.length,
        æ€»æ¶ˆæ¯æ•°: apiMessages.length + 1,
        ç”¨æˆ·æ‹‰é»‘äº†AI: isBlocked,
        AIæ‹‰é»‘äº†ç”¨æˆ·: hasAIBlockedUser
      })
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')
      console.log('ğŸ“¤ å®Œæ•´APIè¯·æ±‚ï¼š')
      console.log([{ role: 'system', content: systemPrompt }, ...apiMessages])
      console.groupEnd()

      const aiReply = await callAIApi(
        [{ role: 'system', content: systemPrompt }, ...apiMessages],
        settings
      )
      
      Logger.log('æ”¶åˆ°AIå›å¤', aiReply)
      
      // AIåŸºæœ¬ä¿¡æ¯
      const aiName = character?.realName || 'AI'
      const aiId = character?.id || chatId
      const aiAvatar = character?.avatar || 'ğŸ¤–'
      
      // å…ˆè§£æAIå‘æœ‹å‹åœˆæŒ‡ä»¤
      const { post: aiMomentsPost, cleanedMessage: messageAfterMomentsPost } = parseAIMomentsPost(
        aiReply,
        aiName,
        aiId,
        aiAvatar
      )
      
      // å¦‚æœAIå‘å¸ƒäº†æœ‹å‹åœˆï¼Œæ‰§è¡Œå‘å¸ƒæ“ä½œ
      if (aiMomentsPost) {
        console.log('ğŸ“± [AIå‘æœ‹å‹åœˆ] æ£€æµ‹åˆ°AIå‘æœ‹å‹åœˆæŒ‡ä»¤:', aiMomentsPost)
        const success = executeAIMomentsPost(aiMomentsPost)
        
        if (success) {
          // åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯
          const systemContent = `${aiName}å‘å¸ƒäº†æœ‹å‹åœˆï¼š"${aiMomentsPost.content}"`
          const systemMessage: Message = {
            ...createMessage(systemContent, 'system'),
            aiReadableContent: `[ç³»ç»Ÿé€šçŸ¥ï¼šä½ å‘å¸ƒäº†æœ‹å‹åœˆ"${aiMomentsPost.content}"ï¼Œå…¶ä»–äººå¯èƒ½ä¼šçœ‹åˆ°å¹¶äº’åŠ¨]`
          }
          
          // å»¶è¿Ÿ300msåæ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
          await new Promise(resolve => setTimeout(resolve, 300))
          
          // æ›´æ–°ReactçŠ¶æ€ï¼ˆsetMessagesä¼šè‡ªåŠ¨ä¿å­˜ï¼‰
          setMessages(prev => [...prev, systemMessage])
          console.log(`ğŸ’¾ [AIå‘æœ‹å‹åœˆ] ç³»ç»Ÿæ¶ˆæ¯å·²ä¿å­˜: ${systemContent}`)
          
          // è°ƒç”¨æœ‹å‹åœˆå¯¼æ¼”ç³»ç»Ÿï¼Œè®©å…¶ä»–AIæ ¹æ®å†…å®¹è¿›è¡Œäº’åŠ¨
          // è·å–åˆšå‘å¸ƒçš„æœ‹å‹åœˆå¯¹è±¡
          const moments = loadMoments()
          const justPostedMoment = moments.find(m => m.userId === aiId && m.content === aiMomentsPost.content)
          
          if (justPostedMoment) {
            console.log('ğŸ¬ [AIå‘æœ‹å‹åœˆ] è§¦å‘å¯¼æ¼”ç³»ç»Ÿï¼Œå‡†å¤‡ç¼–æ’å…¶ä»–AIäº’åŠ¨...')
            // å¼‚æ­¥è°ƒç”¨å¯¼æ¼”ç³»ç»Ÿï¼Œä¸é˜»å¡å½“å‰æµç¨‹
            triggerAIMomentsInteraction(justPostedMoment).catch(error => {
              console.error('âŒ [AIå‘æœ‹å‹åœˆ] å¯¼æ¼”ç³»ç»Ÿè°ƒç”¨å¤±è´¥:', error)
            })
          }
        }
      }
      
      // å†è§£ææœ‹å‹åœˆäº’åŠ¨æŒ‡ä»¤
      const { interactions, cleanedMessage } = parseMomentsInteractions(messageAfterMomentsPost, aiName, aiId)
      
      // å¦‚æœæœ‰æœ‹å‹åœˆäº’åŠ¨æŒ‡ä»¤ï¼Œæ‰§è¡Œå®ƒä»¬
      if (interactions.length > 0) {
        console.log('ğŸ“± æ£€æµ‹åˆ°æœ‹å‹åœˆäº’åŠ¨æŒ‡ä»¤:', interactions)
        const interactionResults = executeMomentsInteractions(interactions)
        console.log('âœ… æœ‹å‹åœˆäº’åŠ¨æ‰§è¡Œç»“æœ:', interactionResults)
        
        // ä¸ºæ¯ä¸ªæˆåŠŸçš„äº’åŠ¨åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯
        for (const result of interactionResults) {
          if (result.success) {
            let systemContent = ''
            let notificationMessage = ''
            
            if (result.type === 'like') {
              systemContent = `${result.aiName}ç‚¹èµäº†ä½ çš„æœ‹å‹åœˆ`
              notificationMessage = `ç‚¹èµäº†ä½ çš„æœ‹å‹åœˆï¼š"${result.momentContent}"`
            } else if (result.type === 'comment') {
              systemContent = `${result.aiName}åœ¨ä½ çš„æœ‹å‹åœˆè¯„è®ºäº†"${result.commentContent}"`
              notificationMessage = `è¯„è®ºäº†ä½ çš„æœ‹å‹åœˆï¼š"${result.commentContent}"`
            } else if (result.type === 'reply') {
              systemContent = `${result.aiName}åœ¨ä½ çš„æœ‹å‹åœˆå›å¤${result.replyTo}"${result.commentContent}"`
              notificationMessage = `å›å¤äº†${result.replyTo}ï¼š"${result.commentContent}"`
            }
            
            // åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯
            const systemMessage: Message = {
              ...createMessage(systemContent, 'system'),
              aiReadableContent: `[ç³»ç»Ÿé€šçŸ¥ï¼š${systemContent}ï¼Œè¿™æ˜¯æœ‹å‹åœˆäº’åŠ¨é€šçŸ¥ï¼Œç”¨æˆ·ä¼šçœ‹åˆ°ç°è‰²å°å­—æç¤º]`
            }
            
            // å»¶è¿Ÿ300msåæ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
            await new Promise(resolve => setTimeout(resolve, 300))
            
            // æ›´æ–°ReactçŠ¶æ€ï¼ˆsetMessagesä¼šè‡ªåŠ¨ä¿å­˜ï¼‰
            setMessages(prev => [...prev, systemMessage])
            console.log(`ğŸ’¾ [æœ‹å‹åœˆäº’åŠ¨] ç³»ç»Ÿæ¶ˆæ¯å·²ä¿å­˜: ${systemContent}`)
            
            // æ˜¾ç¤ºé€šçŸ¥å¼¹çª—
            showNotification(
              chatId,
              result.aiName,
              notificationMessage,
              character?.avatar || 'ğŸ¤–'
            )
            console.log(`ğŸ”” [æœ‹å‹åœˆäº’åŠ¨] é€šçŸ¥å·²æ˜¾ç¤º: ${notificationMessage}`)
          }
        }
      }
      
      // ä½¿ç”¨æ¸…ç†åçš„æ¶ˆæ¯å†…å®¹ç»§ç»­å¤„ç†
      const aiMessagesList = parseAIMessages(cleanedMessage)
      console.log('ğŸ“ AIæ¶ˆæ¯æ‹†åˆ†ç»“æœ:', aiMessagesList)
      
      // ä½¿ç”¨æŒ‡ä»¤å¤„ç†å™¨å¤„ç†æ¯æ¡æ¶ˆæ¯
      let pendingQuotedMsg: Message['quotedMessage'] | undefined // ä¿å­˜è·¨æ¶ˆæ¯çš„å¼•ç”¨
      
      for (let i = 0; i < aiMessagesList.length; i++) {
        const content = aiMessagesList[i]
        console.log(`ğŸ”„ å¤„ç†æ¶ˆæ¯ [${i+1}/${aiMessagesList.length}]: "${content}"`)
        
        let quotedMsg: Message['quotedMessage'] | undefined = pendingQuotedMsg // ç»§æ‰¿ä¸Šä¸€æ¡çš„å¼•ç”¨
        let messageContent = content
        let skipTextMessage = false

        // æŒç»­å¤„ç†æŒ‡ä»¤ç›´åˆ°æ²¡æœ‰æ›´å¤šåŒ¹é…ï¼ˆæœ€å¤š10æ¬¡é˜²æ­¢æ­»å¾ªç¯ï¼‰
        let shouldContinue = true
        let loopCount = 0
        const MAX_LOOPS = 10
        
        while (shouldContinue && loopCount < MAX_LOOPS) {
          shouldContinue = false
          loopCount++
          
          // éå†æ‰€æœ‰æŒ‡ä»¤å¤„ç†å™¨
          for (const handler of commandHandlers) {
            const match = messageContent.match(handler.pattern)
            if (match) {
              console.log(`ğŸ¯ [commandHandler] å¤„ç†æŒ‡ä»¤ï¼ŒisBlocked=${isBlocked}`, {
                pattern: handler.pattern.toString(),
                match: match[0],
                isBlocked
              })
              
              const result = await handler.handler(match, messageContent, {
                messages,
                setMessages,
                character,
                chatId,  // ğŸ”¥ ä¼ å…¥chatIdï¼Œç¡®ä¿æ¶ˆæ¯èƒ½ä¿å­˜åˆ°localStorage
                isBlocked,  // ğŸ”¥ ä¼ å…¥æ‹‰é»‘çŠ¶æ€ï¼Œç¡®ä¿ç‰¹æ®Šæ¶ˆæ¯ä¹Ÿèƒ½æ˜¾ç¤ºæ„Ÿå¹å·
                onVideoCallRequest,
                refreshCharacter  // ğŸ”¥ ä¼ å…¥refreshCharacterï¼Œè®©AIæ”¹ååç«‹å³æ›´æ–°ç•Œé¢
              })

              if (result.handled) {
                // æ£€æŸ¥æ˜¯å¦è·³è¿‡æ–‡æœ¬æ¶ˆæ¯
                if (result.skipTextMessage) {
                  skipTextMessage = true
                }
                
                // ç‰¹æ®Šå¤„ç†å¼•ç”¨æŒ‡ä»¤
                if ('quotedMsg' in result) {
                  quotedMsg = result.quotedMsg
                  messageContent = result.messageContent || ''
                } else if (result.remainingText !== undefined) {
                  messageContent = result.remainingText
                }
                
                // ç»§ç»­æ£€æŸ¥å‰©ä½™æ–‡æœ¬ä¸­æ˜¯å¦è¿˜æœ‰å…¶ä»–æŒ‡ä»¤
                shouldContinue = true
                break
              }
            }
          }
        }

        if (loopCount >= MAX_LOOPS) {
          console.error('âš ï¸ æŒ‡ä»¤å¤„ç†å¾ªç¯æ¬¡æ•°è¿‡å¤šï¼Œå¼ºåˆ¶é€€å‡º')
        }

        // å¦‚æœæœ‰å‰©ä½™æ–‡æœ¬ä¸”ä¸æ˜¯çº¯æŒ‡ä»¤æ¶ˆæ¯ï¼Œå‘é€æ™®é€šæ¶ˆæ¯
        console.log(`âœ… æœ€ç»ˆçŠ¶æ€: skipTextMessage=${skipTextMessage}, messageContent="${messageContent}", hasQuote=${!!quotedMsg}`)
        
        if (!skipTextMessage && messageContent && messageContent.trim()) {
          console.log(`ğŸ’¬ åˆ›å»ºæ™®é€šæ¶ˆæ¯: "${messageContent}"${quotedMsg ? ' [å¸¦å¼•ç”¨]' : ''}`)
          const aiMessage: Message = {
            ...createMessage(messageContent, 'received'),
            quotedMessage: quotedMsg,
            blocked: isBlocked  // æ·»åŠ æ‹‰é»‘æ ‡è®°
          }
          
          // è°ƒè¯•ï¼šè¾“å‡ºå¼•ç”¨æ¶ˆæ¯ä¿¡æ¯
          if (quotedMsg) {
            console.log('ğŸ“ åˆ›å»ºå¸¦å¼•ç”¨çš„æ¶ˆæ¯:', {
              quotedMsg,
              messageContent,
              fullMessage: aiMessage
            })
          }
          
          if (isBlocked) {
            console.log('ğŸš« æ¶ˆæ¯å·²æ ‡è®°ä¸ºè¢«æ‹‰é»‘çŠ¶æ€')
          }
          
          await new Promise(resolve => setTimeout(resolve, 300))
          
          // æ›´æ–°ReactçŠ¶æ€ï¼ˆsetMessagesä¼šè‡ªåŠ¨ä¿å­˜ï¼‰
          setMessages(prev => [...prev, aiMessage])
          console.log(`ğŸ’¾ [useChatAI] AIæ¶ˆæ¯å·²ä¿å­˜`)
          
          pendingQuotedMsg = undefined // å¼•ç”¨å·²ä½¿ç”¨ï¼Œæ¸…é™¤
          
        } else if (quotedMsg && !messageContent.trim()) {
          // å¼•ç”¨æŒ‡ä»¤å•ç‹¬ä¸€è¡Œï¼Œä¿ç•™åˆ°ä¸‹ä¸€æ¡æ¶ˆæ¯
          pendingQuotedMsg = quotedMsg
          
        } else {
          pendingQuotedMsg = undefined
        }
      }
      
    } catch (error) {
      console.error('AIå›å¤å¤±è´¥:', error)
      
      if (error instanceof ChatApiError) {
        setError(error.message)
      } else {
        setError('AIå›å¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
      }
    } finally {
      setIsAiTyping(false)
    }
  }, [character, chatId, setMessages, setError, onVideoCallRequest])  // chatIdå’ŒsetMessageså¿…é¡»ä¿ç•™

  /**
   * é‡æ–°ç”ŸæˆAIå›å¤
   */
  const handleRegenerate = useCallback(() => {
    setMessages(prev => {
      const lastAIIndex = [...prev].reverse().findIndex(msg => msg.type === 'received')
      if (lastAIIndex === -1) {
        setError('æ²¡æœ‰å¯é‡æ–°ç”Ÿæˆçš„AIå›å¤')
        return prev
      }
      
      const actualIndex = prev.length - 1 - lastAIIndex
      return prev.slice(0, actualIndex)
    })
    
    setTimeout(() => {
      handleAIReply()
    }, 100)
  }, [setMessages, setError, handleAIReply])

  return {
    isAiTyping,
    messagesEndRef,
    scrollToBottom,
    handleSend,
    handleAIReply,
    handleRegenerate
  }
}
