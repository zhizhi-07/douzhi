<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>zzæ°”æ³¡ç¼–è¾‘</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
      background: #f2f2f7;
      padding-bottom: 70px;
      font-size: 14px;
    }
    
    .header {
      background: rgba(255,255,255,0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 12px 16px;
      border-bottom: 0.5px solid rgba(0,0,0,0.1);
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .header h1 {
      font-size: 17px;
      font-weight: 600;
      color: #000;
    }
    
    .preview-toggle {
      background: #000;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: white;
      font-size: 12px;
      font-weight: 500;
    }
    
    .preview-toggle:active {
      background: #333;
      transform: scale(0.96);
    }
    
    .container {
      padding: 12px;
      max-width: 100%;
    }
    
    .card {
      background: white;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
      border: 1px solid #f0f0f0;
    }
    
    .card-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #333;
      padding-bottom: 8px;
      border-bottom: 1px solid #f5f5f5;
    }
    
    textarea {
      width: 100%;
      min-height: 150px;
      padding: 10px;
      border: 1px solid #e5e5e5;
      border-radius: 8px;
      font-size: 12px;
      font-family: "SF Mono", Monaco, monospace;
      resize: vertical;
      background: #fafafa;
    }
    
    .btn {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      margin-top: 6px;
      letter-spacing: -0.2px;
    }
    
    .btn-primary {
      background: #000;
      color: white;
    }
    
    .btn-primary:active {
      background: #333;
      transform: scale(0.98);
    }
    
    .btn-success {
      background: #666;
      color: white;
    }
    
    .btn-success:active {
      background: #444;
      transform: scale(0.98);
    }
    
    .control-group {
      margin-bottom: 10px;
      padding: 10px;
      background: #fafafa;
      border-radius: 8px;
      border: 0.5px solid #e5e5e5;
    }
    
    .control-label {
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 6px;
      display: flex;
      justify-content: space-between;
      color: #333;
    }
    
    .control-value {
      color: #666;
      font-family: "SF Mono", Monaco, monospace;
      font-size: 11px;
    }
    
    input[type="range"] {
      width: 100%;
      height: 4px;
      background: #e5e5e5;
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #000;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    
    input[type="color"] {
      width: 100%;
      height: 38px;
      border: 1px solid #e5e5e5;
      border-radius: 6px;
      cursor: pointer;
      padding: 2px;
    }
    
    .preview {
      background: #f0f0f0;
      border-radius: 12px;
      padding: 20px;
      min-height: 300px;
      overflow: visible;
    }
    
    .message-row {
      display: flex;
      margin-bottom: 12px;
      overflow: visible;
    }
    
    .message-row.user {
      justify-content: flex-end;
    }
    
    .message-bubble {
      max-width: 80%;
      display: inline-block;
      word-wrap: break-word;
      word-break: break-word;
      white-space: pre-wrap;
    }
    
    .message-container {
      overflow: visible;
    }
    
    .property-name {
      font-family: "SF Mono", Monaco, monospace;
      font-size: 11px;
      color: #888;
      margin-bottom: 6px;
      font-weight: 500;
    }
    
    .bottom-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 10px 12px;
      border-top: 0.5px solid rgba(0,0,0,0.1);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    
    /* æ‚¬æµ®é¢„è§ˆçª—å£ - æ¨¡æ‹Ÿæ‰‹æœºå±å¹•å®½åº¦ */
    .floating-preview {
      position: fixed;
      top: 80px;
      right: 20px;
      width: 420px; /* åŠ å®½ä»¥å®¹çº³å®Œæ•´æ°”æ³¡ */
      max-height: 650px;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(30px);
      -webkit-backdrop-filter: blur(30px);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      z-index: 1000;
      display: none;
      flex-direction: column;
      overflow: hidden; /* æ”¹ä¸ºhiddené¿å…æº¢å‡º */
      border: 0.5px solid rgba(0,0,0,0.1);
    }
    
    .floating-preview.active {
      display: flex;
    }
    
    .floating-header {
      padding: 12px 16px;
      border-bottom: 0.5px solid rgba(0,0,0,0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: move;
      background: rgba(255,255,255,0.5);
    }
    
    .floating-title {
      font-size: 13px;
      font-weight: 600;
      color: #000;
    }
    
    .floating-close {
      background: #f2f2f7;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #666;
      font-size: 16px;
    }
    
    .floating-close:active {
      background: #e5e5ea;
    }
    
    .floating-content {
      padding: 0;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
    }
    
    @media (min-width: 768px) {
      .container {
        max-width: 100%;
        margin: 0 auto;
      }
    }
    
    @media (max-width: 767px) {
      .floating-preview {
        width: calc(100vw - 40px);
        max-height: 60vh;
        top: 60px;
        right: 10px;
      }
      
      .bottom-bar {
        padding: 8px 10px;
      }
      
      .btn {
        padding: 9px !important;
        font-size: 12px !important;
      }
      
      .card {
        padding: 10px;
        margin-bottom: 8px;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>zzæ°”æ³¡ç¼–è¾‘</h1>
    <div style="display:flex; gap:8px; align-items:center;">
      <button onclick="showAddPropertyModal()" style="padding:6px 12px; background:#666; color:#fff; border:none; border-radius:6px; font-size:12px; cursor:pointer;">+ æ·»åŠ å±æ€§</button>
      <button class="preview-toggle" onclick="toggleFloatingPreview()">é¢„è§ˆ</button>
    </div>
  </div>
  
  <!-- æ‚¬æµ®é¢„è§ˆçª—å£ -->
  <div id="floatingPreview" class="floating-preview">
    <div class="floating-header" id="floatingHeader">
      <span class="floating-title">å®æ—¶é¢„è§ˆ</span>
      <button class="floating-close" onclick="toggleFloatingPreview()">Ã—</button>
    </div>
    <div class="floating-content">
      <!-- å¤´åƒå’Œæ—¶é—´æ ·å¼ï¼ˆç‹¬ç«‹ï¼Œä¸è¢«è¦†ç›–ï¼‰ -->
      <style>
        #floatingPreview .avatar {
          width: 40px !important;
          height: 40px !important;
          border-radius: 50% !important;
          flex-shrink: 0 !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          font-size: 14px !important;
          font-weight: 500 !important;
        }
        
        #floatingPreview .avatar.user {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
          color: white !important;
        }
        
        #floatingPreview .avatar.ai {
          background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%) !important;
          color: white !important;
        }
        
        #floatingPreview .time-label {
          font-size: 11px !important;
          color: #9ca3af !important;
        }
      </style>
      
      <style id="floatingStyle">
        /* é»˜è®¤æ°”æ³¡åŸºç¡€æ ·å¼ - å®Œå…¨æ¨¡æ‹Ÿä½ çš„ç½‘ç«™ */
        .message-container.sent .message-bubble {
          padding: 10px 14px;
          display: inline-block;
          background: #1F2937;
          color: #FFFFFF;
          border-radius: 18px 18px 4px 18px;
          box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.08);
          word-wrap: break-word;
          word-break: break-word;
          white-space: pre-wrap;
          box-sizing: border-box;
          font-size: 14px;
          max-width: 70%;
          min-width: 50px;
        }
        
        .message-container.received .message-bubble {
          padding: 10px 14px;
          display: inline-block;
          background: #FFFFFF;
          color: #1F2937;
          border-radius: 18px 18px 18px 4px;
          box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.08);
          word-wrap: break-word;
          word-break: break-word;
          white-space: pre-wrap;
          box-sizing: border-box;
          font-size: 14px;
          max-width: 70%;
          min-width: 50px;
        }
      </style>
      <div style="background:#ffffff; padding:16px; overflow-x:hidden; overflow-y:auto;">
        <!-- çŸ­æ¶ˆæ¯ -->
        <div class="message-container sent" style="display:flex; align-items:end; gap:8px; margin-bottom:12px; flex-direction:row-reverse;">
          <div class="avatar user" style="flex-shrink:0;">æˆ‘</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="time-label" style="flex-shrink:0;">12:33</div>
            <div class="message-bubble">åœ¨å—</div>
          </div>
        </div>
        
        <div class="message-container received" style="display:flex; align-items:end; gap:8px; margin-bottom:12px;">
          <div class="avatar ai" style="flex-shrink:0;">AI</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="message-bubble">åœ¨çš„~</div>
            <div class="time-label" style="flex-shrink:0;">12:33</div>
          </div>
        </div>
        
        <!-- ä¸­ç­‰é•¿åº¦ -->
        <div class="message-container sent" style="display:flex; align-items:end; gap:8px; margin-bottom:12px; flex-direction:row-reverse;">
          <div class="avatar user" style="flex-shrink:0;">æˆ‘</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="time-label" style="flex-shrink:0;">12:34</div>
            <div class="message-bubble">ä»Šå¤©å¤©æ°”çœŸå¥½ï¼Œè¦ä¸è¦ä¸€èµ·å‡ºå»ç©</div>
          </div>
        </div>
        
        <div class="message-container received" style="display:flex; align-items:end; gap:8px; margin-bottom:12px;">
          <div class="avatar ai" style="flex-shrink:0;">AI</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="message-bubble">å¥½å‘€ï¼æƒ³å»å“ªé‡Œç©å‘¢ï¼Ÿ</div>
            <div class="time-label" style="flex-shrink:0;">12:35</div>
          </div>
        </div>
        
        <!-- é•¿æ¶ˆæ¯ -->
        <div class="message-container sent" style="display:flex; align-items:end; gap:8px; margin-bottom:12px; flex-direction:row-reverse;">
          <div class="avatar user" style="flex-shrink:0;">æˆ‘</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="time-label" style="flex-shrink:0;">12:36</div>
            <div class="message-bubble">æˆ‘çœ‹æœ€è¿‘æ–°å¼€äº†ä¸€å®¶å’–å•¡åº—ï¼Œè£…ä¿®å¾ˆæ–‡è‰ºï¼Œè¯„ä»·ä¹Ÿä¸é”™ã€‚è¦ä¸æˆ‘ä»¬å…ˆå»é‚£è¾¹ååï¼Œç„¶åå†å»å…¬å›­æ•£æ•£æ­¥ï¼Ÿ</div>
          </div>
        </div>
        
        <div class="message-container received" style="display:flex; align-items:end; gap:8px; margin-bottom:12px;">
          <div class="avatar ai" style="flex-shrink:0;">AI</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="message-bubble">å¬èµ·æ¥ä¸é”™ï¼æˆ‘ä¹Ÿæƒ³å°è¯•ä¸€ä¸‹æ–°å¼€çš„å’–å•¡åº—ã€‚å¯¹äº†ï¼Œé‚£å®¶åº—å«ä»€ä¹ˆåå­—ï¼Ÿæˆ‘å…ˆçœ‹çœ‹åœ°å€</div>
            <div class="time-label" style="flex-shrink:0;">12:37</div>
          </div>
        </div>
        
        <!-- è¶…é•¿æ¶ˆæ¯ -->
        <div class="message-container sent" style="display:flex; align-items:end; gap:8px; margin-bottom:12px; flex-direction:row-reverse;">
          <div class="avatar user" style="flex-shrink:0;">æˆ‘</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="time-label" style="flex-shrink:0;">12:38</div>
            <div class="message-bubble">å«"æ—¶å…‰å°ç­‘"ï¼Œåœ¨å¸‚ä¸­å¿ƒå•†ä¸šè¡—é‚£è¾¹ï¼Œåœ°é“2å·çº¿ç›´è¾¾ã€‚åº—é‡Œçš„æ‹›ç‰Œæ˜¯æ‰‹å†²å’–å•¡å’Œè‡ªåˆ¶ç”œå“ï¼Œå¬è¯´è€æ¿æ˜¯ä¸ªå¾ˆæœ‰æƒ³æ³•çš„å¹´è½»äººï¼Œè£…ä¿®èµ°çš„æ˜¯å¤å¤é£æ ¼ï¼Œæœ‰å¾ˆå¤šè€ç‰©ä»¶å’Œç»¿æ¤ï¼Œæ‹ç…§å¾ˆå¥½çœ‹ï¼</div>
          </div>
        </div>
        
        <div class="message-container received" style="display:flex; align-items:end; gap:8px; margin-bottom:12px;">
          <div class="avatar ai" style="flex-shrink:0;">AI</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="message-bubble">å¤ªæ£’äº†ï¼é‚£æˆ‘ä»¬å°±å®šåœ¨ä¸‹åˆ3ç‚¹ï¼Ÿæˆ‘å¸¦ç›¸æœºï¼Œå¯ä»¥å¸®ä½ æ‹å‡ å¼ ç…§ç‰‡</div>
            <div class="time-label" style="flex-shrink:0;">12:40</div>
          </div>
        </div>
        
        <!-- çŸ­å›å¤ -->
        <div class="message-container sent" style="display:flex; align-items:end; gap:8px; margin-bottom:12px; flex-direction:row-reverse;">
          <div class="avatar user" style="flex-shrink:0;">æˆ‘</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="time-label" style="flex-shrink:0;">12:41</div>
            <div class="message-bubble">å¥½ï¼é‚£å°±è¿™ä¹ˆå®šäº†</div>
          </div>
        </div>
        
        <div class="message-container received" style="display:flex; align-items:end; gap:8px; margin-bottom:12px;">
          <div class="avatar ai" style="flex-shrink:0;">AI</div>
          <div style="display:flex; align-items:end; gap:6px;">
            <div class="message-bubble">ğŸ˜Š</div>
            <div class="time-label" style="flex-shrink:0;">12:41</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <div>
      <!-- æ°”æ³¡ç±»å‹åˆ‡æ¢ -->
      <div class="card">
        <div style="display:flex; gap:8px; margin-bottom:12px;">
          <button id="bubbleUserTab" onclick="switchBubbleType('user')" style="flex:1; padding:10px; background:#000; color:#fff; border:none; border-radius:6px; font-size:13px; font-weight:500;">ç”¨æˆ·æ°”æ³¡</button>
          <button id="bubbleAiTab" onclick="switchBubbleType('ai')" style="flex:1; padding:10px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:13px; font-weight:500;">AIæ°”æ³¡</button>
        </div>
        <div id="aiCopyTip" style="display:none; background:#f0f0f0; padding:8px; border-radius:6px; margin-bottom:12px;">
          <button onclick="copyUserToAi()" style="width:100%; padding:8px; background:#000; color:#fff; border:none; border-radius:6px; font-size:12px;">å¤åˆ¶ç”¨æˆ·æ°”æ³¡æ ·å¼</button>
        </div>
      </div>

      <!-- CSSè¾“å…¥ -->
      <div class="card">
        <div class="card-title">å¯¼å…¥CSS</div>
        <textarea id="cssInput" placeholder="ç²˜è´´CSSä»£ç ...&#10;æ”¯æŒ .sent å’Œ .received é€‰æ‹©å™¨" style="min-height:100px;"></textarea>
        <button class="btn btn-primary" onclick="smartParse()">è§£æCSS</button>
      </div>

      <!-- è§£æåçš„åŠ¨æ€æ§ä»¶ -->
      <div class="card">
        <div class="card-title">è§£æå‡ºçš„å±æ€§</div>
        <div id="controls" style="min-height:40px;">
          <div style="color:#999; font-size:12px; text-align:center; padding:20px;">
            è§£æCSSåï¼Œå±æ€§æ§ä»¶ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ
          </div>
        </div>
      </div>

      <!-- è‡ªå®šä¹‰å±æ€§ï¼ˆéšè—æ˜¾ç¤ºï¼‰ -->
      <div id="customControls"></div>

      <!-- æ°”æ³¡å½¢çŠ¶ -->
      <div class="card">
        <div class="card-title">æ°”æ³¡å½¢çŠ¶</div>
        
        <select id="shapeTypeSelect" onchange="changeShapeType(this.value)" style="width:100%; padding:10px; border:1px solid #e5e5e5; border-radius:8px; font-size:13px; background:white; margin-bottom:12px;">
          <option value="default">é»˜è®¤åœ†è§’</option>
          <option value="circle">åœ†å½¢</option>
          <option value="ellipse">æ¤­åœ†</option>
          <option value="triangle">ä¸‰è§’å½¢</option>
          <option value="pentagon">äº”è¾¹å½¢</option>
          <option value="hexagon">å…­è¾¹å½¢</option>
          <option value="octagon">å…«è¾¹å½¢</option>
          <option value="star">æ˜Ÿå½¢</option>
          <option value="heart">å¿ƒå½¢</option>
          <option value="speech">å¯¹è¯æ¡†</option>
          <option value="custom">è‡ªå®šä¹‰</option>
        </select>
        
        <!-- è‡ªå®šä¹‰ç”»æ¿ -->
        <div id="customShapeEditor" style="display:none;">
          <canvas id="shapeCanvas" width="300" height="300" style="display:block; border:1px solid #e5e5e5; border-radius:8px; cursor:crosshair; margin-bottom:10px;"></canvas>
          
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px;">
            <button id="straightModeBtn" onclick="setDrawMode('straight')" style="padding:8px; background:#000; color:#fff; border:none; border-radius:6px; font-size:12px;">ç›´çº¿</button>
            <button id="curveModeBtn" onclick="setDrawMode('curve')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:12px;">æ›²çº¿</button>
          </div>
          
          <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; margin-bottom:10px;">
            <button onclick="clearShapePoints()" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:12px;">æ¸…ç©º</button>
            <button onclick="undoLastPoint()" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:12px;">æ’¤é”€</button>
            <button onclick="applyDrawnShape()" style="padding:8px; background:#000; color:#fff; border:none; border-radius:6px; font-size:12px;">åº”ç”¨</button>
          </div>
          
          <button onclick="showShapeExamples()" style="width:100%; padding:8px; background:#fff; color:#333; border:1px solid #e5e5e5; border-radius:6px; font-size:12px;">é¢„è®¾å½¢çŠ¶</button>
        </div>
        
        <!-- åœ†è§’æ§åˆ¶ï¼ˆä»…åœ¨é»˜è®¤å½¢çŠ¶æ—¶æ˜¾ç¤ºï¼‰ -->
        <div id="radiusControl" style="margin-bottom:12px;">
          <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
            <span>åœ†è§’å¤§å°</span>
            <span id="shape-radius-val" style="color:#666; font-family:monospace;">18px</span>
          </div>
          <input type="range" min="0" max="50" value="18" 
            oninput="updateShapeRadius(this.value); triggerPreviewUpdate();" 
            style="width:100%;">
        </div>
        
        <div style="margin-bottom:12px;">
          <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
            <span>é€æ˜åº¦</span>
            <span id="shape-opacity-val" style="color:#999;">100%</span>
          </div>
          <input type="range" min="0" max="100" value="100" oninput="updateShapeOpacity(this.value); triggerPreviewUpdate();" style="width:100%;">
        </div>
      </div>

      <!-- å±‚çº§æ§åˆ¶ -->
      <div class="card">
        <div class="card-title">å±‚çº§ä¸å®šä½</div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
          <div>
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>Z-Index å±‚çº§</span>
              <span id="zindex-val" style="color:#999;">10</span>
            </div>
            <input type="range" min="0" max="100" value="10" oninput="updateZIndex(this.value); triggerPreviewUpdate();" style="width:100%;">
          </div>
          
          <div>
            <div style="font-size:11px; margin-bottom:4px;">å®šä½æ–¹å¼</div>
            <select onchange="updatePosition(this.value)" style="width:100%; padding:6px; border:1px solid #e5e5e5; border-radius:6px; font-size:12px;">
              <option value="relative">ç›¸å¯¹å®šä½</option>
              <option value="absolute">ç»å¯¹å®šä½</option>
              <option value="fixed">å›ºå®šå®šä½</option>
            </select>
          </div>
        </div>
      </div>

      <!-- è´´çº¸ -->
      <div class="card">
        <div class="card-title">è´´çº¸è£…é¥°</div>
        <div id="stickerButtons" style="margin-bottom:10px;">
          <!-- è´´çº¸æŒ‰é’®ä¼šæ ¹æ®å½“å‰tabåŠ¨æ€æ˜¾ç¤º -->
        </div>
        
        <!-- å›¾åºŠä¸Šä¼ é€‰é¡¹ -->
        <div style="background:#f9f9f9; padding:10px; border-radius:6px; margin-bottom:10px;">
          <div style="font-size:11px; margin-bottom:6px; font-weight:500;">å›¾åºŠä¸Šä¼ ï¼ˆå¯é€‰ï¼‰</div>
          <input type="text" id="imageHostUrl" placeholder="ç²˜è´´å›¾åºŠé“¾æ¥ï¼ˆæ”¯æŒhttps://ï¼‰" style="width:100%; padding:8px; border:1px solid #e5e5e5; border-radius:6px; font-size:12px; margin-bottom:6px;">
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
            <button onclick="applyImageHostBefore()" style="padding:6px; background:#f0f0f0; color:#666; border:none; border-radius:4px; font-size:11px;">åº”ç”¨åˆ°ç”¨æˆ·è´´çº¸</button>
            <button onclick="applyImageHostAfter()" style="padding:6px; background:#f0f0f0; color:#666; border:none; border-radius:4px; font-size:11px;">åº”ç”¨åˆ°AIè´´çº¸</button>
          </div>
        </div>
        
        <div id="pseudoControls"></div>
      </div>

      <!-- èƒŒæ™¯å›¾ -->
      <div class="card">
        <div class="card-title">èƒŒæ™¯å›¾ç‰‡</div>
        <input type="file" id="bgImageInput" accept="image/*" style="display:none;" onchange="handleBgImageUpload(event)">
        <button class="btn btn-primary" onclick="document.getElementById('bgImageInput').click()">é€‰æ‹©å›¾ç‰‡</button>
        <div id="bgImagePreview" style="display:none; margin-top:10px;">
          <img id="bgImageThumb" style="width:100%; border-radius:8px; margin-bottom:8px;">
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
            <button onclick="applyBgImage()" style="padding:8px; background:#000; color:#fff; border:none; border-radius:6px; font-size:12px;">åº”ç”¨</button>
            <button onclick="removeBgImage()" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:12px;">åˆ é™¤</button>
          </div>
        </div>
      </div>

      <!-- æ°”æ³¡åº•å›¾ï¼ˆä¸è§„åˆ™èƒŒæ™¯ï¼‰ -->
      <div class="card">
        <div class="card-title">æ°”æ³¡åº•å›¾</div>
        <div style="font-size:11px; color:#666; margin-bottom:10px; line-height:1.5;">
          ä¸Šä¼ ä¸è§„åˆ™å½¢çŠ¶çš„PNGä½œä¸ºæ°”æ³¡åº•å›¾ï¼ˆå¦‚æ°´å½©ã€ç¬”åˆ·æ•ˆæœï¼‰ï¼Œä¼šè‡ªåŠ¨ä¹å®«æ ¼æ‹‰ä¼¸é€‚åº”å†…å®¹é•¿åº¦ã€‚
        </div>
        <input type="file" id="bubbleBaseInput" accept="image/*" style="display:none;" onchange="handleBubbleBaseUpload(event)">
        <button class="btn btn-primary" onclick="document.getElementById('bubbleBaseInput').click()">é€‰æ‹©åº•å›¾</button>
        <div id="bubbleBasePreview" style="display:none; margin-top:10px;">
          <!-- ä¹å®«æ ¼åˆ‡ç‰‡å¯è§†åŒ– -->
          <div style="position:relative; margin-bottom:12px; background:#000; border-radius:8px; padding:4px;">
            <img id="bubbleBaseThumb" style="width:100%; display:block; border-radius:4px;">
            <svg id="sliceGrid" style="position:absolute; top:4px; left:4px; width:calc(100% - 8px); height:calc(100% - 8px); pointer-events:none;">
              <line id="sliceLineTop" x1="0" y1="30" x2="100%" y2="30" stroke="#ff0" stroke-width="2" stroke-dasharray="4"/>
              <line id="sliceLineRight" x1="100%" y1="0" x2="100%" y2="100%" stroke="#ff0" stroke-width="2" stroke-dasharray="4" transform="translate(-30, 0)"/>
              <line id="sliceLineBottom" x1="0" y1="100%" x2="100%" y2="100%" stroke="#ff0" stroke-width="2" stroke-dasharray="4" transform="translate(0, -30)"/>
              <line id="sliceLineLeft" x1="30" y1="0" x2="30" y2="100%" stroke="#ff0" stroke-width="2" stroke-dasharray="4"/>
              <text x="10" y="20" fill="#ff0" font-size="12" font-weight="bold">ä¸Š</text>
              <text x="calc(100% - 30)" y="20" fill="#ff0" font-size="12" font-weight="bold">å³</text>
              <text x="10" y="calc(100% - 10)" fill="#ff0" font-size="12" font-weight="bold">ä¸‹</text>
              <text x="10" y="50%" fill="#ff0" font-size="12" font-weight="bold">å·¦</text>
            </svg>
          </div>
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; padding:8px; background:#f8f8f8; border-radius:6px;">
            <div style="font-size:10px; color:#666; line-height:1.4;">
              <strong style="color:#ff0;">é»„è‰²è™šçº¿</strong> = åˆ‡ç‰‡çº¿<br>
              æ‹–åŠ¨æ»‘å—çœ‹çº¿åŠ¨
            </div>
            <label style="display:flex; align-items:center; gap:6px; font-size:11px; cursor:pointer;">
              <input type="checkbox" id="toggleSliceLines" checked onchange="toggleSliceVisibility()" style="cursor:pointer;">
              æ˜¾ç¤ºåˆ‡ç‰‡çº¿
            </label>
          </div>
          <details style="margin-bottom:10px;">
            <summary style="padding:8px; background:#fff3cd; border-left:3px solid #ffc107; border-radius:4px; cursor:pointer; font-size:11px; font-weight:500;">
              ğŸ’¡ è°ƒæ•´æŠ€å·§ï¼ˆç‚¹å‡»å±•å¼€ï¼‰
            </summary>
            <div style="font-size:10px; color:#666; margin-top:6px; padding:8px; background:#f8f8f8; border-radius:4px; line-height:1.6;">
              â€¢ é»„çº¿è¦åˆ‡åœ¨<strong>è£…é¥°ç‰©è¾¹ç¼˜</strong><br>
              â€¢ æ‹–åŠ¨æ»‘å—ï¼Œ<strong>çœ‹é»„çº¿ç§»åŠ¨</strong><br>
              â€¢ å››ä¸ªè§’è½åº”è¯¥ä¿ç•™å®Œæ•´
            </div>
          </details>
          
          <div style="margin-bottom:10px;">
            <div style="font-size:11px; margin-bottom:8px; font-weight:500;">
              ä¹å®«æ ¼åˆ‡ç‰‡ï¼ˆç²¾ç»†è°ƒæ•´ï¼‰
            </div>
            
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
              <div>
                <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                  <span>ä¸Šè¾¹ç¼˜</span>
                  <span id="slice-top-val" style="color:#666;">30px</span>
                </div>
                <input type="range" min="5" max="80" value="30" step="1" id="sliceTopSlider" 
                  oninput="updateBubbleBaseSliceDetail('top', this.value)" style="width:100%;">
              </div>
              
              <div>
                <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                  <span>å³è¾¹ç¼˜</span>
                  <span id="slice-right-val" style="color:#666;">30px</span>
                </div>
                <input type="range" min="5" max="80" value="30" step="1" id="sliceRightSlider" 
                  oninput="updateBubbleBaseSliceDetail('right', this.value)" style="width:100%;">
              </div>
              
              <div>
                <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                  <span>ä¸‹è¾¹ç¼˜</span>
                  <span id="slice-bottom-val" style="color:#666;">30px</span>
                </div>
                <input type="range" min="5" max="80" value="30" step="1" id="sliceBottomSlider" 
                  oninput="updateBubbleBaseSliceDetail('bottom', this.value)" style="width:100%;">
              </div>
              
              <div>
                <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                  <span>å·¦è¾¹ç¼˜</span>
                  <span id="slice-left-val" style="color:#666;">30px</span>
                </div>
                <input type="range" min="5" max="80" value="30" step="1" id="sliceLeftSlider" 
                  oninput="updateBubbleBaseSliceDetail('left', this.value)" style="width:100%;">
              </div>
            </div>
            
            <div style="font-size:10px; color:#999; margin-top:6px; line-height:1.4;">
              ğŸ’¡ å“ªè¾¹è¢«æ‹‰ä¼¸ï¼Œå°±æŠŠé‚£è¾¹çš„å€¼è°ƒå¤§<br>
              å››ä¸ªæ–¹å‘å¯ç‹¬ç«‹è°ƒæ•´
            </div>
          </div>
          
          <div style="margin-bottom:10px;">
            <div style="font-size:11px; margin-bottom:8px; font-weight:500; display:flex; align-items:center; gap:8px;">
              <span>è¾¹æ¡†æ¸²æŸ“å®½åº¦</span>
              <label style="display:flex; align-items:center; gap:4px; font-size:10px; font-weight:normal; cursor:pointer;">
                <input type="checkbox" id="uniformPadding" checked onchange="toggleUniformPadding()" style="cursor:pointer;">
                <span>ç»Ÿä¸€</span>
              </label>
            </div>
            
            <!-- ç»Ÿä¸€æ¨¡å¼ -->
            <div id="uniformPaddingControl" style="margin-bottom:8px;">
              <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                <span>å››è¾¹ç»Ÿä¸€</span>
                <span id="bubble-padding-val" style="color:#666;">15px</span>
              </div>
              <input type="range" min="5" max="50" value="15" id="bubblePaddingSlider" 
                oninput="updateBubbleBasePadding(this.value)" style="width:100%;">
            </div>
            
            <!-- ç‹¬ç«‹æ¨¡å¼ -->
            <div id="separatePaddingControl" style="display:none;">
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:8px;">
                <div>
                  <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                    <span>ä¸Š</span>
                    <span id="padding-top-val" style="color:#666;">15px</span>
                  </div>
                  <input type="range" min="5" max="50" value="15" id="paddingTopSlider" 
                    oninput="updatePaddingSeparate('top', this.value)" style="width:100%;">
                </div>
                <div>
                  <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                    <span>å³</span>
                    <span id="padding-right-val" style="color:#666;">15px</span>
                  </div>
                  <input type="range" min="5" max="50" value="15" id="paddingRightSlider" 
                    oninput="updatePaddingSeparate('right', this.value)" style="width:100%;">
                </div>
                <div>
                  <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                    <span>ä¸‹</span>
                    <span id="padding-bottom-val" style="color:#666;">15px</span>
                  </div>
                  <input type="range" min="5" max="50" value="15" id="paddingBottomSlider" 
                    oninput="updatePaddingSeparate('bottom', this.value)" style="width:100%;">
                </div>
                <div>
                  <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                    <span>å·¦</span>
                    <span id="padding-left-val" style="color:#666;">15px</span>
                  </div>
                  <input type="range" min="5" max="50" value="15" id="paddingLeftSlider" 
                    oninput="updatePaddingSeparate('left', this.value)" style="width:100%;">
                </div>
              </div>
            </div>
            
            <div style="font-size:10px; color:#999; line-height:1.4;">
              ğŸ’¡ æ§åˆ¶åº•å›¾è¾¹æ¡†çš„æ˜¾ç¤ºå¤§å°<br>
              ğŸ“ ç‹¬ç«‹æ¨¡å¼å¯åˆ†åˆ«è°ƒæ•´å››è¾¹<br>
              â­ <strong>ç®€åŒ–ç‰ˆï¼š</strong>å¸ƒå±€æ›´ç¨³å®šï¼Œä¸ä¼šä¹±é£
            </div>
          </div>
          
          <div style="margin-bottom:12px;">
            <div style="font-size:11px; margin-bottom:6px; font-weight:500;">
              å®½åº¦æ§åˆ¶
            </div>
            
            <div style="display:flex; gap:8px; margin-bottom:8px;">
              <button onclick="setWidthMode('percent')" id="widthPercentBtn" style="flex:1; padding:6px; background:#000; color:#fff; border:none; border-radius:4px; font-size:11px;">ç™¾åˆ†æ¯”</button>
              <button onclick="setWidthMode('pixel')" id="widthPixelBtn" style="flex:1; padding:6px; background:#f0f0f0; color:#666; border:none; border-radius:4px; font-size:11px;">åƒç´ </button>
            </div>
            
            <div id="widthPercentControl">
              <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                <span>æœ€å¤§å®½åº¦ï¼ˆå±å¹•ç™¾åˆ†æ¯”ï¼‰</span>
                <span id="bubble-maxwidth-percent-val" style="color:#666;">65%</span>
              </div>
              <input type="range" min="20" max="100" value="65" step="1" id="bubbleMaxWidthPercentSlider" 
                oninput="updateBubbleMaxWidthPercent(this.value)" style="width:100%;">
            </div>
            
            <div id="widthPixelControl" style="display:none;">
              <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                <span>æœ€å¤§å®½åº¦ï¼ˆåƒç´ å€¼ï¼‰</span>
                <span id="bubble-maxwidth-pixel-val" style="color:#666;">300px</span>
              </div>
              <input type="range" min="100" max="800" value="300" step="10" id="bubbleMaxWidthPixelSlider" 
                oninput="updateBubbleMaxWidthPixel(this.value)" style="width:100%;">
            </div>
            
            <div style="font-size:10px; color:#999; margin-top:6px; line-height:1.4;">
              <strong style="color:#f60;">è‡ªç”±è°ƒæ•´ï¼</strong><br>
              ç™¾åˆ†æ¯”=ç›¸å¯¹å±å¹• / åƒç´ =å›ºå®šå¤§å°
            </div>
          </div>
          
          <div style="margin-bottom:12px;">
            <div style="font-size:11px; margin-bottom:6px; font-weight:500;">
              å­—ä½“å¤§å°
            </div>
            <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>æ–‡å­—å¤§å°</span>
              <span id="bubble-fontsize-val" style="color:#666;">14px</span>
            </div>
            <input type="range" min="12" max="20" value="14" step="1" id="bubbleFontSizeSlider" 
              oninput="updateBubbleFontSize(this.value)" style="width:100%;">
            <div style="font-size:10px; color:#999; margin-top:4px;">
              ğŸ’¡ è°ƒæ•´é¢„è§ˆå’Œå®é™…æ°”æ³¡çš„å­—ä½“å¤§å°
            </div>
          </div>
          
          <div style="margin-bottom:12px;">
            <div style="font-size:11px; margin-bottom:6px; font-weight:500;">
              æ–‡å­—å†…è¾¹è·ï¼ˆç²¾ç»†å¯¹é½ï¼‰
            </div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
              <div>
                <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                  <span>ä¸Šä¸‹</span>
                  <span id="text-padding-v-val" style="color:#666;">10px</span>
                </div>
                <input type="range" min="0" max="30" value="10" step="1" id="textPaddingVSlider" 
                  oninput="updateTextPadding('v', this.value)" style="width:100%;">
              </div>
              <div>
                <div style="font-size:10px; margin-bottom:4px; display:flex; justify-content:space-between;">
                  <span>å·¦å³</span>
                  <span id="text-padding-h-val" style="color:#666;">12px</span>
                </div>
                <input type="range" min="0" max="30" value="12" step="1" id="textPaddingHSlider" 
                  oninput="updateTextPadding('h', this.value)" style="width:100%;">
              </div>
            </div>
            <div style="font-size:10px; color:#999; margin-top:4px; line-height:1.4;">
              ğŸ’¡ <strong>å…³é”®ï¼</strong>è°ƒæ•´å·¦å³paddingå¯ä»¥å¾®è°ƒå¯¹é½<br>
              â€¢ æ–‡å­—åå·¦ï¼Ÿå¢å¤§å·¦å³å€¼<br>
              â€¢ æ–‡å­—åå³ï¼Ÿå‡å°å·¦å³å€¼
            </div>
          </div>
          
          <div style="margin-bottom:12px; padding:12px; background:#e3f2fd; border:2px solid #2196F3; border-radius:6px;">
            <div style="font-size:12px; font-weight:600; margin-bottom:8px; color:#1976D2;">
              ğŸ¨ åº•å›¾æ¨¡å¼
            </div>
            <select id="bubbleBaseMode" onchange="updateBubbleBaseMode(this.value)" style="width:100%; padding:10px; border:2px solid #2196F3; border-radius:6px; font-size:13px; font-weight:500; background:#fff;">
              <option value="nine-slice">ä¹å®«æ ¼æ‹‰ä¼¸ï¼ˆè§„åˆ™è¾¹æ¡†ï¼‰</option>
              <option value="fixed-shape" selected>å›ºå®šå½¢çŠ¶ï¼ˆä¸è§„åˆ™è£…é¥°ï¼‰â­</option>
            </select>
            <div style="font-size:10px; color:#1565C0; margin-top:6px; line-height:1.4;">
              â­ <strong>å›ºå®šå½¢çŠ¶ï¼š</strong>é€‚åˆçŒ«å’ªã€åŠ¨ç‰©ç­‰ä¸è§„åˆ™åº•å›¾<br>
              ğŸ“ <strong>ä¹å®«æ ¼æ‹‰ä¼¸ï¼š</strong>é€‚åˆåœ†è§’çŸ©å½¢ã€ç›´çº¿è¾¹æ¡†
            </div>
          </div>
          
          <div id="nineSliceControls" style="display:none;">
            <div style="margin-bottom:10px;">
              <div style="font-size:11px; margin-bottom:6px;">æ‹‰ä¼¸æ¨¡å¼</div>
              <select id="bubbleBaseRepeat" onchange="updateBubbleBaseRepeat(this.value)" style="width:100%; padding:8px; border:1px solid #e5e5e5; border-radius:6px; font-size:12px;">
                <option value="stretch" selected>æ‹‰ä¼¸ï¼ˆæ¨èï¼‰</option>
                <option value="repeat">é‡å¤</option>
                <option value="round">åœ†è§’é‡å¤</option>
                <option value="space">é—´éš”é‡å¤</option>
              </select>
            </div>
          </div>
          
          <div style="margin-bottom:12px; padding:12px; background:#fff3cd; border:1px solid #ffc107; border-radius:6px;">
            <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:12px; font-weight:500;">
              <input type="checkbox" id="removeBackgroundColor" checked onchange="toggleBackgroundRemoval()" style="cursor:pointer; width:16px; height:16px;">
              <span>â­ æ¶ˆé™¤åº•å—ï¼ˆå¼ºåˆ¶é€æ˜èƒŒæ™¯ï¼‰</span>
            </label>
            <div style="font-size:10px; color:#856404; margin-top:6px; line-height:1.4;">
              âœ… å‹¾é€‰ï¼šå®Œå…¨æ¶ˆé™¤æ°”æ³¡å‘¨å›´çš„åº•è‰²<br>
              âŒ ä¸å‹¾é€‰ï¼šä¿ç•™border-image-widthçš„åº•è‰²
            </div>
          </div>
          
          <div style="margin-bottom:10px;">
            <div style="font-size:11px; margin-bottom:6px;">å¿«æ·é¢„è®¾</div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px; font-size:11px;">
              <button onclick="applyPreset('compact')" style="padding:6px; background:#f8f8f8; border:1px solid #e0e0e0; border-radius:4px; cursor:pointer;">ç´§å‡‘</button>
              <button onclick="applyPreset('normal')" style="padding:6px; background:#f8f8f8; border:1px solid #e0e0e0; border-radius:4px; cursor:pointer;">æ ‡å‡†</button>
              <button onclick="applyPreset('wide')" style="padding:6px; background:#f8f8f8; border:1px solid #e0e0e0; border-radius:4px; cursor:pointer;">å®½æ¾</button>
              <button onclick="applyPreset('full')" style="padding:6px; background:#f8f8f8; border:1px solid #e0e0e0; border-radius:4px; cursor:pointer;">æœ€å¤§</button>
            </div>
            <div style="font-size:10px; color:#999; margin-top:4px;">
              ä¸€é”®åº”ç”¨å¸¸ç”¨é…ç½®ç»„åˆ
            </div>
          </div>
          
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
            <button onclick="applyBubbleBase()" style="padding:10px; background:#000; color:#fff; border:none; border-radius:6px; font-size:13px; font-weight:500;">åº”ç”¨</button>
            <button onclick="removeBubbleBase()" style="padding:10px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:13px;">åˆ é™¤</button>
          </div>
        </div>
      </div>

      <!-- ç‰¹æ•ˆå¢å¼º -->
      <div class="card">
        <div class="card-title">è§†è§‰ç‰¹æ•ˆ</div>
        
        <!-- è¾¹ç¼˜ç¾½åŒ– -->
        <div style="margin-bottom:12px;">
          <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
            <span>è¾¹ç¼˜ç¾½åŒ–</span>
            <span id="edge-soft-val" style="color:#999;">0px</span>
          </div>
          <input type="range" min="0" max="25" value="0" oninput="updateEdgeSoft(this.value); triggerPreviewUpdate();" style="width:100%;">
          <div style="font-size:10px; color:#999; margin-top:4px;">
            è¾¹ç¼˜è‡ªç„¶è½¯åŒ–ï¼ˆæ— çº¿æ¡†åŒ…è£¹ï¼‰
          </div>
        </div>
        
        <!-- å¤–å‘å…‰ -->
        <div style="margin-bottom:12px;">
          <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
            <span>å¤–å‘å…‰å¼ºåº¦</span>
            <span id="outer-glow-val" style="color:#999;">0px</span>
          </div>
          <input type="range" min="0" max="30" value="0" id="outerGlowSlider" oninput="updateOuterGlow(this.value); triggerPreviewUpdate();" style="width:100%;">
          <input type="color" id="outerGlowColor" value="#ffffff" onchange="updateOuterGlow()" style="width:100%; height:32px; margin-top:6px;">
        </div>
        
        <!-- å†…å‘å…‰ -->
        <div style="margin-bottom:12px;">
          <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
            <span>å†…å‘å…‰å¼ºåº¦</span>
            <span id="inner-glow-val" style="color:#999;">0px</span>
          </div>
          <input type="range" min="0" max="20" value="0" id="innerGlowSlider" oninput="updateInnerGlow(this.value); triggerPreviewUpdate();" style="width:100%;">
          <input type="color" id="innerGlowColor" value="#ffffff" onchange="updateInnerGlow()" style="width:100%; height:32px; margin-top:6px;">
        </div>
        
        <!-- æ–œé¢ä¸æµ®é›• -->
        <div style="margin-bottom:12px;">
          <div style="font-size:11px; margin-bottom:6px;">æ–œé¢ä¸æµ®é›•</div>
          <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:6px;">
            <button onclick="applyBevel('none')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">æ— </button>
            <button onclick="applyBevel('raised')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">å‡¸èµ·</button>
            <button onclick="applyBevel('inset')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">å†…å‡¹</button>
          </div>
        </div>
      </div>

      <!-- æ¸å˜èƒŒæ™¯ -->
      <div class="card">
        <div class="card-title">æ¸å˜èƒŒæ™¯</div>
        
        <div style="font-size:11px; margin-bottom:6px;">æ¸å˜ç±»å‹</div>
        <select id="gradientType" onchange="updateGradientType(this.value)" style="width:100%; padding:8px; border:1px solid #e5e5e5; border-radius:6px; font-size:12px; margin-bottom:12px;">
          <option value="none">æ— æ¸å˜</option>
          <option value="linear">çº¿æ€§æ¸å˜</option>
          <option value="radial">å¾„å‘æ¸å˜</option>
        </select>
        
        <div id="gradientControls" style="display:none;">
          <div style="margin-bottom:12px;">
            <div style="font-size:11px; margin-bottom:6px;">èµ·å§‹é¢œè‰²</div>
            <input type="color" id="gradientColor1" value="#667eea" onchange="updateGradient()" style="width:100%; height:36px;">
          </div>
          
          <div style="margin-bottom:12px;">
            <div style="font-size:11px; margin-bottom:6px;">ç»“æŸé¢œè‰²</div>
            <input type="color" id="gradientColor2" value="#764ba2" onchange="updateGradient()" style="width:100%; height:36px;">
          </div>
          
          <div id="linearAngle" style="display:none; margin-bottom:12px;">
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>æ¸å˜è§’åº¦</span>
              <span id="gradient-angle-val" style="color:#999;">45deg</span>
            </div>
            <input type="range" min="0" max="360" value="45" oninput="updateGradientAngle(this.value); triggerPreviewUpdate();" style="width:100%;">
          </div>
        </div>
      </div>

      <!-- é«˜çº§æ»¤é•œ -->
      <div class="card">
        <div class="card-title">é«˜çº§æ»¤é•œ</div>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:12px;">
          <div>
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>å¯¹æ¯”åº¦</span>
              <span id="contrast-val" style="color:#999;">100%</span>
            </div>
            <input type="range" min="0" max="200" value="100" oninput="updateContrast(this.value); triggerPreviewUpdate();" style="width:100%;">
          </div>
          
          <div>
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>é¥±å’Œåº¦</span>
              <span id="saturate-val" style="color:#999;">100%</span>
            </div>
            <input type="range" min="0" max="200" value="100" oninput="updateSaturate(this.value); triggerPreviewUpdate();" style="width:100%;">
          </div>
        </div>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
          <div>
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>äº®åº¦</span>
              <span id="brightness-val" style="color:#999;">100%</span>
            </div>
            <input type="range" min="0" max="200" value="100" oninput="updateBrightness(this.value); triggerPreviewUpdate();" style="width:100%;">
          </div>
          
          <div>
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>è‰²ç›¸</span>
              <span id="hue-val" style="color:#999;">0deg</span>
            </div>
            <input type="range" min="0" max="360" value="0" oninput="updateHue(this.value); triggerPreviewUpdate();" style="width:100%;">
          </div>
        </div>
      </div>

      <!-- æ–‡å­—ç‰¹æ•ˆ -->
      <div class="card">
        <div class="card-title">æ–‡å­—ç‰¹æ•ˆ</div>
        
        <div style="margin-bottom:12px;">
          <div style="font-size:11px; margin-bottom:6px;">æ–‡å­—é¢œè‰²</div>
          <input type="color" id="textColorPicker" value="#000000" onchange="updateTextColor(this.value)" style="width:100%; height:36px;">
        </div>
        
        <div style="margin-bottom:12px;">
          <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
            <span>æ–‡å­—é˜´å½±å¼ºåº¦</span>
            <span id="text-shadow-val" style="color:#999;">0px</span>
          </div>
          <input type="range" min="0" max="10" value="0" id="textShadowSlider" oninput="updateTextShadow(this.value); triggerPreviewUpdate();" style="width:100%;">
          <input type="color" id="textShadowColor" value="#000000" onchange="updateTextShadow()" style="width:100%; height:32px; margin-top:6px;">
        </div>
        
        <div style="font-size:11px; margin-bottom:6px;">æ··åˆæ¨¡å¼</div>
        <select onchange="updateBlendMode(this.value)" style="width:100%; padding:8px; border:1px solid #e5e5e5; border-radius:6px; font-size:12px;">
          <option value="normal">æ­£å¸¸</option>
          <option value="multiply">æ­£ç‰‡å åº•</option>
          <option value="screen">æ»¤è‰²</option>
          <option value="overlay">å åŠ </option>
          <option value="darken">å˜æš—</option>
          <option value="lighten">å˜äº®</option>
          <option value="color-dodge">é¢œè‰²å‡æ·¡</option>
          <option value="color-burn">é¢œè‰²åŠ æ·±</option>
          <option value="difference">å·®å€¼</option>
          <option value="exclusion">æ’é™¤</option>
        </select>
      </div>

      <!-- åŠ¨ç”»æ•ˆæœ -->
      <div class="card">
        <div class="card-title">åŠ¨ç”»æ•ˆæœ</div>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px;">
          <button onclick="applyAnimation('pulse')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">å‘¼å¸</button>
          <button onclick="applyAnimation('bounce')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">å¼¹è·³</button>
          <button onclick="applyAnimation('shake')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">æŠ–åŠ¨</button>
          <button onclick="applyAnimation('glow')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">é—ªå…‰</button>
        </div>
        
        <button onclick="removeAnimation()" style="width:100%; padding:8px; background:#fff; color:#666; border:1px solid #e5e5e5; border-radius:6px; font-size:11px;">ç§»é™¤åŠ¨ç”»</button>
      </div>

      <!-- é¢„è®¾æ¨¡æ¿ -->
      <div class="card">
        <div class="card-title">é¢„è®¾æ¨¡æ¿</div>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px;">
          <button onclick="loadPreset('glassmorphism')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">ç»ç’ƒæ€</button>
          <button onclick="loadPreset('neumorphism')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">æ–°æ‹Ÿæ€</button>
          <button onclick="loadPreset('neon')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">éœ“è™¹ç¯</button>
          <button onclick="loadPreset('minimal')" style="padding:8px; background:#f0f0f0; color:#666; border:none; border-radius:6px; font-size:11px;">æç®€</button>
        </div>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
          <button onclick="saveCurrentAsPreset()" style="padding:8px; background:#000; color:#fff; border:none; border-radius:6px; font-size:11px;">ä¿å­˜å½“å‰</button>
          <button onclick="exportPreset()" style="padding:8px; background:#666; color:#fff; border:none; border-radius:6px; font-size:11px;">å¯¼å‡ºé…ç½®</button>
        </div>
      </div>

      <!-- CSSè¾“å‡º -->
      <div class="card">
        <div class="card-title">ç”Ÿæˆçš„CSSä»£ç </div>
        <textarea id="cssOutput" readonly style="min-height:120px;"></textarea>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:10px;">
          <button onclick="promptSaveStyle()" style="padding:10px; background:#000; color:#fff; border:none; border-radius:6px; font-size:13px; font-weight:500; cursor:pointer;">ä¿å­˜æ ·å¼</button>
          <button onclick="showStylesLibrary()" style="padding:10px; background:#666; color:#fff; border:none; border-radius:6px; font-size:13px; font-weight:500; cursor:pointer;">æ ·å¼åº“</button>
        </div>
      </div>
    </div>
  </div>

  <!-- æ ·å¼åº“æ¨¡æ€æ¡† -->
  <div id="stylesLibraryModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; align-items:center; justify-content:center;">
    <div style="background:white; border-radius:14px; padding:20px; max-width:600px; width:90%; max-height:80vh; overflow:auto; box-shadow:0 8px 32px rgba(0,0,0,0.3);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
        <h3 style="margin:0; font-size:18px; font-weight:600;">æ ·å¼åº“</h3>
        <button onclick="hideStylesLibrary()" style="padding:4px 12px; background:#f0f0f0; border:none; border-radius:6px; cursor:pointer;">å…³é—­</button>
      </div>
      <div id="stylesLibraryList" style="margin-bottom:12px;">
        <!-- æ ·å¼åˆ—è¡¨ä¼šåŠ¨æ€ç”Ÿæˆ -->
      </div>
      <button onclick="promptSaveStyle()" style="width:100%; padding:10px; background:#000; color:#fff; border:none; border-radius:6px; font-size:13px; font-weight:500; cursor:pointer;">+ ä¿å­˜å½“å‰æ ·å¼</button>
    </div>
  </div>
  
  <style id="dynamicStyle"></style>

  <!-- åº•éƒ¨æŒ‰é’® -->
  <div class="bottom-bar">
    <button onclick="copyCSS()" style="padding:12px; background:#000; color:#fff; border:none; border-radius:8px; font-size:13px; font-weight:500;">å¤åˆ¶CSS</button>
    <button onclick="saveCSS()" style="padding:12px; background:#666; color:#fff; border:none; border-radius:8px; font-size:13px; font-weight:500;">ä¿å­˜</button>
  </div>

  <!-- æ·»åŠ å±æ€§å¼¹çª— -->
  <div id="addPropertyModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.4); z-index:9999; padding:20px;">
    <div style="background:white; border-radius:14px; padding:16px; max-width:360px; margin:80px auto; box-shadow:0 8px 32px rgba(0,0,0,0.2);">
      <h3 style="margin-bottom:12px; font-size:15px; font-weight:600;">æ·»åŠ CSSå±æ€§</h3>
      <select id="newPropertySelect" style="width:100%; padding:10px; border:1px solid #d1d1d6; border-radius:8px; margin-bottom:10px; font-size:13px; background:white;">
        <option value="">-- é€‰æ‹©å±æ€§ --</option>
        <optgroup label="å¸ƒå±€">
          <option value="display">displayï¼ˆæ˜¾ç¤ºæ–¹å¼ï¼‰</option>
          <option value="position">positionï¼ˆå®šä½ï¼‰</option>
          <option value="top">topï¼ˆä¸Šè¾¹è·ï¼‰</option>
          <option value="left">leftï¼ˆå·¦è¾¹è·ï¼‰</option>
          <option value="right">rightï¼ˆå³è¾¹è·ï¼‰</option>
          <option value="bottom">bottomï¼ˆä¸‹è¾¹è·ï¼‰</option>
          <option value="z-index">z-indexï¼ˆå±‚çº§ï¼‰</option>
          <option value="overflow">overflowï¼ˆæº¢å‡ºï¼‰</option>
          <option value="max-width">max-widthï¼ˆæœ€å¤§å®½åº¦ï¼‰</option>
          <option value="width">widthï¼ˆå®½åº¦ï¼‰</option>
          <option value="height">heightï¼ˆé«˜åº¦ï¼‰</option>
        </optgroup>
        <optgroup label="é—´è·">
          <option value="padding">paddingï¼ˆå†…è¾¹è·ï¼‰</option>
          <option value="margin">marginï¼ˆå¤–è¾¹è·ï¼‰</option>
          <option value="padding-top">padding-topï¼ˆä¸Šå†…è¾¹è·ï¼‰</option>
          <option value="padding-bottom">padding-bottomï¼ˆä¸‹å†…è¾¹è·ï¼‰</option>
          <option value="padding-left">padding-leftï¼ˆå·¦å†…è¾¹è·ï¼‰</option>
          <option value="padding-right">padding-rightï¼ˆå³å†…è¾¹è·ï¼‰</option>
        </optgroup>
        <optgroup label="è¾¹æ¡†">
          <option value="border">borderï¼ˆè¾¹æ¡†ï¼‰</option>
          <option value="border-radius">border-radiusï¼ˆåœ†è§’ï¼‰</option>
          <option value="border-top">border-topï¼ˆä¸Šè¾¹æ¡†ï¼‰</option>
          <option value="border-bottom">border-bottomï¼ˆä¸‹è¾¹æ¡†ï¼‰</option>
          <option value="border-left">border-leftï¼ˆå·¦è¾¹æ¡†ï¼‰</option>
          <option value="border-right">border-rightï¼ˆå³è¾¹æ¡†ï¼‰</option>
        </optgroup>
        <optgroup label="èƒŒæ™¯">
          <option value="background-color">background-colorï¼ˆèƒŒæ™¯è‰²ï¼‰</option>
          <option value="background">backgroundï¼ˆèƒŒæ™¯ï¼‰</option>
          <option value="background-image">background-imageï¼ˆèƒŒæ™¯å›¾ï¼‰</option>
          <option value="background-size">background-sizeï¼ˆèƒŒæ™¯å°ºå¯¸ï¼‰</option>
          <option value="background-position">background-positionï¼ˆèƒŒæ™¯ä½ç½®ï¼‰</option>
        </optgroup>
        <optgroup label="æ–‡å­—">
          <option value="color">colorï¼ˆæ–‡å­—é¢œè‰²ï¼‰</option>
          <option value="font-size">font-sizeï¼ˆå­—ä½“å¤§å°ï¼‰</option>
          <option value="font-weight">font-weightï¼ˆå­—ä½“ç²—ç»†ï¼‰</option>
          <option value="line-height">line-heightï¼ˆè¡Œé«˜ï¼‰</option>
          <option value="text-align">text-alignï¼ˆå¯¹é½æ–¹å¼ï¼‰</option>
          <option value="word-break">word-breakï¼ˆæ¢è¡Œï¼‰</option>
        </optgroup>
        <optgroup label="æ•ˆæœ">
          <option value="box-shadow">box-shadowï¼ˆé˜´å½±ï¼‰</option>
          <option value="text-shadow">text-shadowï¼ˆæ–‡å­—é˜´å½±ï¼‰</option>
          <option value="opacity">opacityï¼ˆé€æ˜åº¦ï¼‰</option>
          <option value="backdrop-filter">backdrop-filterï¼ˆèƒŒæ™¯æ¨¡ç³Šï¼‰</option>
        </optgroup>
        <optgroup label="åŠ¨ç”»">
          <option value="transform">transformï¼ˆå˜æ¢ï¼‰</option>
          <option value="transition">transitionï¼ˆè¿‡æ¸¡ï¼‰</option>
          <option value="animation">animationï¼ˆåŠ¨ç”»ï¼‰</option>
        </optgroup>
      </select>
      <div style="display:flex; gap:8px;">
        <button class="btn btn-success" onclick="addNewProperty()" style="flex:1; padding:10px; font-size:13px;">æ·»åŠ </button>
        <button class="btn" onclick="closeAddPropertyModal()" style="flex:1; padding:10px; font-size:13px; background:#f2f2f7; color:#000;">å–æ¶ˆ</button>
      </div>
    </div>
  </div>

  <script>
    // å­˜å‚¨è§£æçš„CSSå±æ€§ï¼ˆåŒ…å«é»˜è®¤font-sizeå’Œpaddingï¼‰
    let parsedStyles = {
      'font-size': {
        type: 'size',
        size: 14,
        original: '14px'
      },
      'padding': {
        type: 'text',
        value: '10px 12px',
        original: '10px 12px'
      }
    };
    let currentCSS = '';

    // å­˜å‚¨é¢å¤–çš„CSSï¼ˆä¼ªå…ƒç´ ã€åŠ¨ç”»ç­‰ï¼‰
    let extraCSS = {
      beforePseudo: '',
      afterPseudo: '',
      animations: ''
    };

    // æ™ºèƒ½è§£æCSS
    function smartParse() {
      const cssText = document.getElementById('cssInput').value;
      if (!cssText.trim()) {
        alert('è¯·å…ˆç²˜è´´CSSä»£ç ');
        return;
      }

      // æå– .sent éƒ¨åˆ†ï¼ˆå¤„ç†å¤šè¡ŒåµŒå¥—ï¼‰
      const sentRegex = /\.sent[^{]*\.message-bubble\s*\{/;
      const sentMatch = sentRegex.exec(cssText);
      if (!sentMatch) {
        alert('æœªæ‰¾åˆ° .sent é€‰æ‹©å™¨');
        return;
      }

      let braceCount = 1;
      let endPos = sentMatch.index + sentMatch[0].length;
      while (braceCount > 0 && endPos < cssText.length) {
        if (cssText[endPos] === '{') braceCount++;
        if (cssText[endPos] === '}') braceCount--;
        endPos++;
      }
      
      const cssContent = cssText.substring(sentMatch.index + sentMatch[0].length, endPos - 1);
      currentCSS = cssContent;
      
      // æå– ::before ä¼ªå…ƒç´ ï¼ˆå¤„ç†å¤šè¡Œï¼‰
      const beforeRegex = /\.sent[^{]*\.message-bubble::before\s*\{/;
      const beforeMatch = beforeRegex.exec(cssText);
      if (beforeMatch) {
        let braceCount = 1;
        let endPos = beforeMatch.index + beforeMatch[0].length;
        while (braceCount > 0 && endPos < cssText.length) {
          if (cssText[endPos] === '{') braceCount++;
          if (cssText[endPos] === '}') braceCount--;
          endPos++;
        }
        extraCSS.beforePseudo = cssText.substring(beforeMatch.index, endPos);
        console.log('æ‰¾åˆ° ::before ä¼ªå…ƒç´ ');
      }
      
      // æå– ::after ä¼ªå…ƒç´ ï¼ˆå¤„ç†å¤šè¡Œï¼‰
      const afterRegex = /\.received[^{]*\.message-bubble::after\s*\{/;
      const afterMatch = afterRegex.exec(cssText);
      if (afterMatch) {
        let braceCount = 1;
        let endPos = afterMatch.index + afterMatch[0].length;
        while (braceCount > 0 && endPos < cssText.length) {
          if (cssText[endPos] === '{') braceCount++;
          if (cssText[endPos] === '}') braceCount--;
          endPos++;
        }
        extraCSS.afterPseudo = cssText.substring(afterMatch.index, endPos);
        console.log('æ‰¾åˆ° ::after ä¼ªå…ƒç´ ');
      }
      
      // æå– @keyframes åŠ¨ç”»ï¼ˆå¤„ç†åµŒå¥—å¤§æ‹¬å·ï¼‰
      const keyframesMatches = [];
      let tempText = cssText;
      let match;
      const keyframesRegex = /@keyframes\s+[\w-]+\s*\{/g;
      
      while ((match = keyframesRegex.exec(tempText)) !== null) {
        const startPos = match.index;
        let braceCount = 1;
        let endPos = match.index + match[0].length;
        
        // æ‰‹åŠ¨è§£æåµŒå¥—å¤§æ‹¬å·
        while (braceCount > 0 && endPos < tempText.length) {
          if (tempText[endPos] === '{') braceCount++;
          if (tempText[endPos] === '}') braceCount--;
          endPos++;
        }
        
        keyframesMatches.push(tempText.substring(startPos, endPos));
      }
      
      if (keyframesMatches.length > 0) {
        extraCSS.animations = keyframesMatches.join('\n\n');
        console.log('æ‰¾åˆ°åŠ¨ç”»:', keyframesMatches.length, 'ä¸ª');
      }
      
      // è§£ææ‰€æœ‰CSSå±æ€§
      parsedStyles = parseAllProperties(cssContent);
      
      // ç”Ÿæˆæ§ä»¶
      generateControls(parsedStyles);
      
      // ç”Ÿæˆä¼ªå…ƒç´ æ§ä»¶
      generatePseudoControls();
      
      // ç«‹å³æ›´æ–°é¢„è§ˆ
      setTimeout(() => {
        updatePreview();
      }, 100);
      
      const extras = [];
      if (extraCSS.beforePseudo) extras.push('::beforeä¼ªå…ƒç´ ');
      if (extraCSS.afterPseudo) extras.push('::afterä¼ªå…ƒç´ ');
      if (extraCSS.animations) extras.push('@keyframesåŠ¨ç”»');
      
      const extraMsg = extras.length > 0 ? `\né¢å¤–è§£æ: ${extras.join('ã€')}` : '';
      alert(`æˆåŠŸè§£æ ${Object.keys(parsedStyles).length} ä¸ªCSSå±æ€§ï¼${extraMsg}\nç°åœ¨å¯ä»¥è°ƒæ•´æ§ä»¶äº†`);
    }

    // è§£ææ‰€æœ‰CSSå±æ€§
    function parseAllProperties(cssText) {
      const styles = {};
      
      // åˆ†å‰²æˆå•ç‹¬çš„å±æ€§
      const properties = cssText.split(';').filter(p => p.trim());
      
      properties.forEach(prop => {
        const [name, value] = prop.split(':').map(s => s.trim());
        if (name && value) {
          const cleanName = name.replace(/^\s+|\s+$/g, '');
          const cleanValue = value.replace(/!important/g, '').trim();
          styles[cleanName] = parsePropertyValue(cleanName, cleanValue);
        }
      });
      
      return styles;
    }

    // CSSå±æ€§æ˜ å°„è¡¨ï¼ˆè‡ªåŠ¨è¯†åˆ«å¯ç¼–è¾‘å±æ€§ï¼‰
    const editableProperties = {
      // é¢œè‰²ç±»
      'color': {category: 'color', max: 100},
      'background': {category: 'color', max: 100},
      'background-color': {category: 'color', max: 100},
      'border-color': {category: 'color', max: 100},
      'text-shadow': {category: 'shadow'},
      'box-shadow': {category: 'shadow'},
      
      // å°ºå¯¸ç±»
      'border-radius': {category: 'size', max: 50},
      'border-width': {category: 'size', max: 10},
      'font-size': {category: 'size', max: 30},
      'padding': {category: 'size', max: 50},
      'padding-top': {category: 'size', max: 50},
      'padding-bottom': {category: 'size', max: 50},
      'padding-left': {category: 'size', max: 50},
      'padding-right': {category: 'size', max: 50},
      'margin': {category: 'size', max: 50},
      'width': {category: 'size', max: 500},
      'height': {category: 'size', max: 500},
      'line-height': {category: 'size', max: 50},
      'letter-spacing': {category: 'size', max: 10},
      
      // æ•°å€¼ç±»
      'opacity': {category: 'percent', max: 100},
      'font-weight': {category: 'number', max: 900, step: 100}
    };

    // æ·±åº¦è§£æCSSå±æ€§å€¼ - æ”¯æŒä»»ä½•å¤æ‚CSS
    function parsePropertyValue(name, value) {
      const parsed = {
        original: value,
        type: 'text',
        value: value,
        editable: [],
        rawParts: []  // ä¿å­˜åŸå§‹ç»“æ„
      };

      // 1. è§£æ backdrop-filter
      if (name.includes('backdrop-filter') || name.includes('-webkit-backdrop-filter')) {
        const blurMatch = value.match(/blur\((\d+)px\)/);
        if (blurMatch) {
          parsed.type = 'backdrop';
          parsed.blurValue = parseInt(blurMatch[1]);
          parsed.editable.push({type: 'range', label: 'æ¨¡ç³Šå¼ºåº¦', key: 'blurValue', min: 0, max: 50, unit: 'px'});
        }
        return parsed;
      }

      // 2. è§£æå¤šå±‚ box-shadow
      if (name === 'box-shadow') {
        const shadows = [];
        // åˆ†å‰²å¤šå±‚é˜´å½±ï¼ˆå¤„ç†é€—å·åˆ†éš”ï¼‰
        const parts = value.split(/,(?![^()]*\))/);
        parts.forEach((shadow, idx) => {
          const isInset = shadow.includes('inset');
          const numbers = shadow.match(/(-?\d+(?:\.\d+)?)px/g);
          if (numbers && numbers.length >= 2) {
            const shadowData = {
              isInset,
              x: parseInt(numbers[0]),
              y: parseInt(numbers[1]),
              blur: numbers[2] ? parseInt(numbers[2]) : 0,
              spread: numbers[3] ? parseInt(numbers[3]) : 0
            };
            shadows.push(shadowData);
            
            // ä¸ºæ¯å±‚é˜´å½±åˆ›å»ºæ§ä»¶ï¼ˆåŒ…æ‹¬X/Yåç§»ï¼‰
            const prefix = isInset ? 'å†…é˜´å½±' : 'å¤–é˜´å½±';
            parsed.editable.push({type: 'range', label: `${prefix}${idx+1} å·¦å³åç§»`, key: `shadow${idx}X`, min: -50, max: 50, unit: 'px', shadowIndex: idx});
            parsed.editable.push({type: 'range', label: `${prefix}${idx+1} ä¸Šä¸‹åç§»`, key: `shadow${idx}Y`, min: -50, max: 50, unit: 'px', shadowIndex: idx});
            parsed.editable.push({type: 'range', label: `${prefix}${idx+1} æ¨¡ç³Š`, key: `shadow${idx}Blur`, min: 0, max: 50, unit: 'px', shadowIndex: idx});
            if (shadowData.spread !== undefined) {
              parsed.editable.push({type: 'range', label: `${prefix}${idx+1} æ‰©æ•£`, key: `shadow${idx}Spread`, min: 0, max: 20, unit: 'px', shadowIndex: idx});
            }
          }
        });
        parsed.type = 'multishadow';
        parsed.shadows = shadows;
        return parsed;
      }

      // 3. è§£æ linear-gradient
      if (value.includes('linear-gradient')) {
        const angleMatch = value.match(/(\d+)deg/);
        const colorMatches = value.match(/rgba?\([^)]+\)/g);
        
        parsed.type = 'gradient';
        parsed.gradientAngle = angleMatch ? parseInt(angleMatch[1]) : 135;
        parsed.gradientColors = [];
        
        if (colorMatches) {
          colorMatches.forEach((colorStr, idx) => {
            const rgbaMatch = colorStr.match(/rgba?\(\s*(\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (rgbaMatch) {
              const r = parseInt(rgbaMatch[1]);
              const g = parseInt(rgbaMatch[2]);
              const b = parseInt(rgbaMatch[3]);
              const a = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;
              const hex = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
              
              parsed.gradientColors.push({hex, alpha: Math.round(a * 100)});
              parsed.editable.push({type: 'color', label: `æ¸å˜è‰²${idx+1}`, key: `gradColor${idx}`, colorIndex: idx});
              parsed.editable.push({type: 'range', label: `æ¸å˜è‰²${idx+1}é€æ˜åº¦`, key: `gradAlpha${idx}`, min: 0, max: 100, unit: '%', colorIndex: idx});
            }
          });
        }
        
        parsed.editable.push({type: 'range', label: 'æ¸å˜è§’åº¦', key: 'gradientAngle', min: 0, max: 360, unit: 'Â°'});
        return parsed;
      }

      // 4. è§£ææ™®é€šé¢œè‰²
      if (name.includes('color') || name === 'background' || name === 'background-color') {
        // rgba/rgb
        const rgbaMatch = value.match(/rgba?\(\s*(\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
        if (rgbaMatch) {
          const r = parseInt(rgbaMatch[1]);
          const g = parseInt(rgbaMatch[2]);
          const b = parseInt(rgbaMatch[3]);
          const a = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;
          parsed.type = 'color';
          parsed.color = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
          parsed.alpha = Math.round(a * 100);
          parsed.editable.push({type: 'color', label: 'é¢œè‰²', key: 'color'});
          parsed.editable.push({type: 'range', label: 'é€æ˜åº¦', key: 'alpha', min: 0, max: 100, unit: '%'});
        }
        
        // hex
        const hexMatch = value.match(/#([0-9a-f]{6})/i);
        if (hexMatch) {
          parsed.type = 'color';
          parsed.color = '#' + hexMatch[1];
          parsed.editable.push({type: 'color', label: 'é¢œè‰²', key: 'color'});
        }

        // linear-gradient
        if (value.includes('linear-gradient')) {
          parsed.type = 'gradient';
          const colors = value.match(/#[0-9a-f]{6}/gi) || [];
          const angle = value.match(/(\d+)deg/);
          parsed.gradientColors = colors;
          parsed.gradientAngle = angle ? parseInt(angle[1]) : 135;
          parsed.editable.push({type: 'range', label: 'æ¸å˜è§’åº¦', key: 'gradientAngle', min: 0, max: 360, unit: 'Â°'});
        }
      }

      // 5. è§£æborderï¼ˆå¤åˆå±æ€§ï¼‰
      if (name === 'border' || name.includes('border-') && !name.includes('radius')) {
        const pxMatch = value.match(/(\d+)px/);
        const colorMatch = value.match(/#[0-9a-f]{6}/i) || value.match(/rgba?\([^)]+\)/);
        
        if (pxMatch) {
          parsed.type = 'border';
          parsed.borderWidth = parseInt(pxMatch[1]);
          parsed.borderColor = colorMatch ? colorMatch[0] : '#000000';
          parsed.borderStyle = value.match(/solid|dashed|dotted|double/) ? value.match(/solid|dashed|dotted|double/)[0] : 'solid';
          
          parsed.editable.push({type: 'range', label: 'è¾¹æ¡†å®½åº¦', key: 'borderWidth', min: 0, max: 10, unit: 'px'});
          parsed.editable.push({type: 'color', label: 'è¾¹æ¡†é¢œè‰²', key: 'borderColor'});
        }
        return parsed;
      }

      // 6. è§£æå°ºå¯¸ï¼ˆé€šç”¨ï¼‰
      if (name.includes('radius') || name.includes('width') || name.includes('size') || name.includes('padding') || name.includes('margin')) {
        const pxMatch = value.match(/(\d+)px/);
        if (pxMatch) {
          parsed.type = 'size';
          parsed.size = parseInt(pxMatch[1]);
          const max = name.includes('radius') ? 50 : name.includes('size') ? 30 : 100;
          parsed.editable.push({type: 'range', label: name, key: 'size', min: 0, max: max, unit: 'px'});
        }
        return parsed;
      }

      // 7. è§£æopacity
      if (name === 'opacity') {
        parsed.type = 'opacity';
        parsed.opacityValue = Math.round(parseFloat(value) * 100);
        parsed.editable.push({type: 'range', label: 'é€æ˜åº¦', key: 'opacityValue', min: 0, max: 100, unit: '%'});
        return parsed;
      }

      // 8. è§£æfont-weight
      if (name === 'font-weight') {
        parsed.type = 'weight';
        parsed.weightValue = parseInt(value);
        parsed.editable.push({type: 'range', label: 'å­—ä½“ç²—ç»†', key: 'weightValue', min: 100, max: 900, unit: '', step: 100});
        return parsed;
      }

      // 9. è§£ætransformï¼ˆæ‰©å±•æ”¯æŒï¼‰
      if (name === 'transform') {
        parsed.type = 'transform';
        
        // è§£æ translateX
        const translateXMatch = value.match(/translateX\((-?\d+)px\)/);
        if (translateXMatch) {
          parsed.translateX = parseInt(translateXMatch[1]);
          parsed.editable.push({type: 'range', label: 'å·¦å³ä½ç§»', key: 'translateX', min: -100, max: 100, unit: 'px'});
        }
        
        // è§£æ translateY
        const translateYMatch = value.match(/translateY\((-?\d+)px\)/);
        if (translateYMatch) {
          parsed.translateY = parseInt(translateYMatch[1]);
          parsed.editable.push({type: 'range', label: 'ä¸Šä¸‹ä½ç§»', key: 'translateY', min: -100, max: 100, unit: 'px'});
        }
        
        // è§£æ scale
        const scaleMatch = value.match(/scale\(([\d.]+)\)/);
        if (scaleMatch) {
          parsed.scaleValue = Math.round(parseFloat(scaleMatch[1]) * 100);
          parsed.editable.push({type: 'range', label: 'ç¼©æ”¾', key: 'scaleValue', min: 50, max: 150, unit: '%'});
        }
        
        // è§£æ rotate
        const rotateMatch = value.match(/rotate\((-?\d+)deg\)/);
        if (rotateMatch) {
          parsed.rotateValue = parseInt(rotateMatch[1]);
          parsed.editable.push({type: 'range', label: 'æ—‹è½¬', key: 'rotateValue', min: -180, max: 180, unit: 'Â°'});
        }
        
        return parsed;
      }

      // 10. è§£æline-height
      if (name === 'line-height') {
        const numMatch = value.match(/([\d.]+)/);
        if (numMatch) {
          parsed.type = 'lineheight';
          parsed.lineHeightValue = Math.round(parseFloat(numMatch[1]) * 10);
          parsed.editable.push({type: 'range', label: 'è¡Œé«˜', key: 'lineHeightValue', min: 5, max: 30, unit: ''});
        }
        return parsed;
      }

      // 11. è§£æz-index
      if (name === 'z-index') {
        parsed.type = 'zindex';
        parsed.zValue = parseInt(value);
        parsed.editable.push({type: 'range', label: 'å±‚çº§', key: 'zValue', min: -10, max: 100, unit: ''});
        return parsed;
      }

      // 12. è§£æmax-width (ç™¾åˆ†æ¯”)
      if (name === 'max-width' && value.includes('%')) {
        parsed.type = 'maxwidth';
        parsed.maxWidthValue = parseInt(value);
        parsed.editable.push({type: 'range', label: 'æœ€å¤§å®½åº¦', key: 'maxWidthValue', min: 0, max: 100, unit: '%'});
        return parsed;
      }

      // 13. è§£ætransition
      if (name === 'transition') {
        const secondsMatch = value.match(/([\d.]+)s/);
        if (secondsMatch) {
          parsed.type = 'transition';
          parsed.transitionDuration = Math.round(parseFloat(secondsMatch[1]) * 10);
          parsed.editable.push({type: 'range', label: 'è¿‡æ¸¡æ—¶é•¿', key: 'transitionDuration', min: 0, max: 30, unit: 's'});
        }
        return parsed;
      }

      // 14. è§£æå®šä½å±æ€§ (top/left/right/bottom)
      if (name === 'top' || name === 'left' || name === 'right' || name === 'bottom') {
        const pxMatch = value.match(/(-?\d+)px/);
        if (pxMatch) {
          parsed.type = 'position';
          parsed.posValue = parseInt(pxMatch[1]);
          parsed.editable.push({type: 'range', label: name, key: 'posValue', min: -100, max: 100, unit: 'px'});
        }
        return parsed;
      }

      // 15. è§£ætext-shadow
      if (name === 'text-shadow') {
        const numbers = value.match(/(-?\d+(?:\.\d+)?)px/g);
        if (numbers && numbers.length >= 2) {
          parsed.type = 'textshadow';
          parsed.textShadowX = parseInt(numbers[0]);
          parsed.textShadowY = parseInt(numbers[1]);
          parsed.textShadowBlur = numbers[2] ? parseInt(numbers[2]) : 0;
          
          parsed.editable.push({type: 'range', label: 'å·¦å³åç§»', key: 'textShadowX', min: -20, max: 20, unit: 'px'});
          parsed.editable.push({type: 'range', label: 'ä¸Šä¸‹åç§»', key: 'textShadowY', min: -20, max: 20, unit: 'px'});
          parsed.editable.push({type: 'range', label: 'æ¨¡ç³Š', key: 'textShadowBlur', min: 0, max: 20, unit: 'px'});
        }
        return parsed;
      }

      // é»˜è®¤ï¼šä¸å¯ç¼–è¾‘ï¼Œä¿æŒåŸæ ·
      return parsed;
    }

    // ç”Ÿæˆæ§ä»¶
    function generateControls(styles) {
      const container = document.getElementById('controls');
      if (!container) return;
      
      container.innerHTML = '';
      
      // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿stylesæ˜¯æœ‰æ•ˆå¯¹è±¡
      if (!styles || typeof styles !== 'object') {
        console.warn('generateControls: styleså‚æ•°æ— æ•ˆ');
        return;
      }

      Object.entries(styles).forEach(([name, data]) => {
        if (data.editable && data.editable.length > 0) {
          const group = document.createElement('div');
          group.className = 'control-group';
          
          const title = document.createElement('div');
          title.className = 'property-name';
          title.textContent = name;
          group.appendChild(title);

          data.editable.forEach(control => {
            const controlDiv = document.createElement('div');
            controlDiv.style.marginBottom = '12px';

            const label = document.createElement('div');
            label.className = 'control-label';
            
            // è·å–æ˜¾ç¤ºå€¼
            let displayValue = '';
            if (control.colorIndex !== undefined && data.gradientColors && data.gradientColors[control.colorIndex]) {
              displayValue = data.gradientColors[control.colorIndex].hex;
            } else if (data.type === 'border' && control.key === 'borderColor') {
              displayValue = data.borderColor || '#000000';
            } else if (data.type === 'border' && control.key === 'borderWidth') {
              displayValue = (data.borderWidth || 1) + (control.unit || '');
            } else if (control.shadowIndex !== undefined) {
              // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿shadowsæ•°ç»„å’Œå¯¹åº”ç´¢å¼•çš„å…ƒç´ å­˜åœ¨
              if (data.shadows && data.shadows[control.shadowIndex]) {
                const shadow = data.shadows[control.shadowIndex];
                let val;
                if (control.key.includes('X')) val = shadow.x;
                else if (control.key.includes('Y')) val = shadow.y;
                else if (control.key.includes('Blur')) val = shadow.blur;
                else if (control.key.includes('Spread')) val = shadow.spread;
                displayValue = val + (control.unit || '');
              } else {
                displayValue = '0' + (control.unit || '');
              }
            } else if (data.type === 'lineheight') {
              displayValue = ((data.lineHeightValue || 15) / 10).toFixed(1);
            } else if (data.type === 'transition') {
              displayValue = ((data.transitionDuration || 3) / 10).toFixed(1) + 's';
            } else {
              displayValue = (data[control.key] || 0) + (control.unit || '');
            }
            
            label.innerHTML = `
              <span>${control.label}</span>
              <span class="control-value" id="value-${name}-${control.key}">${displayValue}</span>
            `;
            controlDiv.appendChild(label);

            if (control.type === 'color') {
              const colorInput = document.createElement('input');
              colorInput.type = 'color';
              
              // å¤„ç†æ¸å˜è‰²
              if (control.colorIndex !== undefined && data.gradientColors && data.gradientColors[control.colorIndex]) {
                colorInput.value = data.gradientColors[control.colorIndex].hex;
                colorInput.oninput = () => {
                  data[control.key] = colorInput.value;
                  console.log('æ¸å˜è‰²æ”¹å˜:', control.colorIndex, colorInput.value);
                  const valueEl = document.getElementById(`value-${name}-${control.key}`);
                  if (valueEl) valueEl.textContent = colorInput.value;
                  updatePreviewFromControls();
                };
              } 
              // å¤„ç†borderé¢œè‰²
              else if (data.type === 'border' && control.key === 'borderColor') {
                colorInput.value = data.borderColor.includes('#') ? data.borderColor : '#000000';
                colorInput.oninput = () => {
                  data.borderColor = colorInput.value;
                  console.log('è¾¹æ¡†é¢œè‰²æ”¹å˜:', colorInput.value);
                  const valueEl = document.getElementById(`value-${name}-${control.key}`);
                  if (valueEl) valueEl.textContent = colorInput.value;
                  updatePreviewFromControls();
                };
              }
              // æ™®é€šé¢œè‰²
              else {
                colorInput.value = data[control.key];
                colorInput.oninput = () => {
                  data[control.key] = colorInput.value;
                  console.log('é¢œè‰²æ”¹å˜:', name, colorInput.value);
                  const valueEl = document.getElementById(`value-${name}-${control.key}`);
                  if (valueEl) valueEl.textContent = colorInput.value;
                  updatePreviewFromControls();
                };
              }
              
              colorInput.onchange = colorInput.oninput;
              controlDiv.appendChild(colorInput);
            } else if (control.type === 'range') {
              const rangeInput = document.createElement('input');
              rangeInput.type = 'range';
              rangeInput.min = control.min;
              rangeInput.max = control.max;
              
              // å¤„ç†æ¸å˜é€æ˜åº¦
              if (control.colorIndex !== undefined && control.key.includes('Alpha') && data.gradientColors && data.gradientColors[control.colorIndex]) {
                rangeInput.value = data.gradientColors[control.colorIndex].alpha;
                rangeInput.oninput = () => {
                  data[control.key] = parseInt(rangeInput.value);
                  console.log('æ¸å˜é€æ˜åº¦æ”¹å˜:', control.colorIndex, rangeInput.value);
                  document.getElementById(`value-${name}-${control.key}`).textContent = rangeInput.value + (control.unit || '');
                  updatePreviewFromControls();
                };
              }
              // å¤„ç†é˜´å½±
              else if (control.shadowIndex !== undefined && data.shadows && data.shadows[control.shadowIndex]) {
                const shadow = data.shadows[control.shadowIndex];
                let initVal;
                if (control.key.includes('X')) initVal = shadow.x;
                else if (control.key.includes('Y')) initVal = shadow.y;
                else if (control.key.includes('Blur')) initVal = shadow.blur;
                else if (control.key.includes('Spread')) initVal = shadow.spread;
                
                rangeInput.value = initVal;
                data[control.key] = initVal;  // åˆå§‹åŒ–
                rangeInput.oninput = () => {
                  data[control.key] = parseInt(rangeInput.value);
                  console.log('é˜´å½±æ”¹å˜:', control.key, rangeInput.value);
                  document.getElementById(`value-${name}-${control.key}`).textContent = rangeInput.value + (control.unit || '');
                  updatePreviewFromControls();
                };
              }
              // å¤„ç†borderå®½åº¦
              else if (data.type === 'border' && control.key === 'borderWidth') {
                rangeInput.value = data.borderWidth || 1;
                rangeInput.oninput = () => {
                  data.borderWidth = parseInt(rangeInput.value);
                  console.log('è¾¹æ¡†å®½åº¦æ”¹å˜:', rangeInput.value);
                  document.getElementById(`value-${name}-${control.key}`).textContent = rangeInput.value + (control.unit || '');
                  updatePreviewFromControls();
                };
              }
              // å¤„ç†line-height
              else if (data.type === 'lineheight') {
                rangeInput.value = data.lineHeightValue || 15;
                rangeInput.oninput = () => {
                  data.lineHeightValue = parseInt(rangeInput.value);
                  console.log('è¡Œé«˜æ”¹å˜:', rangeInput.value);
                  document.getElementById(`value-${name}-${control.key}`).textContent = (rangeInput.value / 10).toFixed(1);
                  updatePreviewFromControls();
                };
              }
              // å¤„ç†transition
              else if (data.type === 'transition') {
                rangeInput.value = data.transitionDuration || 3;
                rangeInput.oninput = () => {
                  data.transitionDuration = parseInt(rangeInput.value);
                  console.log('è¿‡æ¸¡æ—¶é•¿æ”¹å˜:', rangeInput.value);
                  document.getElementById(`value-${name}-${control.key}`).textContent = (rangeInput.value / 10).toFixed(1) + 's';
                  updatePreviewFromControls();
                };
              }
              // å…¶ä»–æ™®é€šæ»‘å—
              else {
                rangeInput.value = data[control.key];
                rangeInput.oninput = () => {
                  data[control.key] = parseInt(rangeInput.value);
                  console.log('æ»‘å—æ”¹å˜:', name, control.key, rangeInput.value);
                  document.getElementById(`value-${name}-${control.key}`).textContent = rangeInput.value + (control.unit || '');
                  updatePreviewFromControls();
                };
              }
              
              controlDiv.appendChild(rangeInput);
            }

            group.appendChild(controlDiv);
          });

          container.appendChild(group);
        }
      });

      if (container.innerHTML === '') {
        container.innerHTML = '<p style="color:#999;text-align:center;padding:20px;">è¯·å…ˆè§£æCSSä»¥ç”Ÿæˆæ§ä»¶</p>';
      }
    }

    // ä»æ§ä»¶æ›´æ–°é¢„è§ˆ
    function updatePreviewFromControls() {
      // ç¡®ä¿åŸºç¡€æ ·å¼å­˜åœ¨ï¼ˆå¦‚æœæ²¡æœ‰è‡ªå®šä¹‰æ ·å¼ï¼Œä½¿ç”¨é»˜è®¤å€¼ï¼‰
      const ensureBaseStyles = (styles) => {
        const base = {
          'padding': { type: 'text', value: '10px 14px', original: '10px 14px' },
          'display': { type: 'text', value: 'inline-block', original: 'inline-block' },
          'word-wrap': { type: 'text', value: 'break-word', original: 'break-word' },
          'box-sizing': { type: 'text', value: 'border-box', original: 'border-box' }
        };
        
        // åˆå¹¶ï¼Œä¿ç•™ç”¨æˆ·è‡ªå®šä¹‰çš„æ ·å¼
        return { ...base, ...styles };
      };
      
      let css = '';
      
      // ç”Ÿæˆç”¨æˆ·æ°”æ³¡CSSï¼ˆåŒ…å«åŸºç¡€æ ·å¼ï¼‰
      css += generateBubbleCSS('.message-container.sent .message-bubble', ensureBaseStyles(userStyles));
      
      // ç”ŸæˆAIæ°”æ³¡CSSï¼ˆåŒ…å«åŸºç¡€æ ·å¼ï¼‰
      css += generateBubbleCSS('.message-container.received .message-bubble', ensureBaseStyles(aiStyles));
      
      // æ·»åŠ ä¼ªå…ƒç´ å’ŒåŠ¨ç”»ï¼ˆå¸¦HTMLç»“æ„è¯´æ˜ï¼‰
      if (extraCSS.beforePseudo || extraCSS.afterPseudo) {
        css += '/* ==================== ä¼ªå…ƒç´ ï¼ˆè´´çº¸è£…é¥°ï¼‰ ==================== */\n';
        css += '/* æ­¤CSSä½¿ç”¨çš„HTMLç»“æ„æ¨¡å¼ï¼š';
        
        if (htmlStructureMode === 'full') {
          css += 'å®Œæ•´ç»“æ„\n';
          css += '   éœ€è¦çš„HTMLï¼š\n';
          css += '   <div class="message-container sent">\n';
          css += '     <div class="message-bubble">ç”¨æˆ·æ¶ˆæ¯</div>\n';
          css += '   </div>\n';
          css += '   <div class="message-container received">\n';
          css += '     <div class="message-bubble">AIæ¶ˆæ¯</div>\n';
          css += '   </div>\n';
        } else if (htmlStructureMode === 'simple') {
          css += 'ç®€åŒ–ç»“æ„\n';
          css += '   éœ€è¦çš„HTMLï¼š\n';
          css += '   <div class="sent">ç”¨æˆ·æ¶ˆæ¯</div>\n';
          css += '   <div class="received">AIæ¶ˆæ¯</div>\n';
        } else if (htmlStructureMode === 'bubble') {
          css += 'ä»…æ°”æ³¡\n';
          css += '   éœ€è¦çš„HTMLï¼š\n';
          css += '   <div class="message-bubble sent">ç”¨æˆ·æ¶ˆæ¯</div>\n';
          css += '   <div class="message-bubble received">AIæ¶ˆæ¯</div>\n';
        }
        
        css += '*/\n\n';
      }
      
      if (extraCSS.beforePseudo) {
        css += extraCSS.beforePseudo + '\n\n';
      }
      if (extraCSS.afterPseudo) {
        css += extraCSS.afterPseudo + '\n\n';
      }
      if (extraCSS.animations) {
        css += extraCSS.animations;
      }

      document.getElementById('dynamicStyle').textContent = css;
      document.getElementById('floatingStyle').textContent = css;
      document.getElementById('cssOutput').value = css;
    }

    // ç”ŸæˆHTMLç»“æ„ç¤ºä¾‹
    function updateHtmlStructureExample() {
      const htmlStructureEl = document.getElementById('htmlStructure');
      if (!htmlStructureEl) return;
      
      let html = '';
      
      if (htmlStructureMode === 'full') {
        html = `<!-- ç”¨æˆ·æ¶ˆæ¯ -->
<div class="message-container sent">
  <div class="message-bubble">è¿™æ˜¯ç”¨æˆ·å‘é€çš„æ¶ˆæ¯</div>
</div>

<!-- AIæ¶ˆæ¯ -->
<div class="message-container received">
  <div class="message-bubble">è¿™æ˜¯AIçš„å›å¤æ¶ˆæ¯</div>
</div>`;
      } else if (htmlStructureMode === 'simple') {
        html = `<!-- ç”¨æˆ·æ¶ˆæ¯ -->
<div class="sent">è¿™æ˜¯ç”¨æˆ·å‘é€çš„æ¶ˆæ¯</div>

<!-- AIæ¶ˆæ¯ -->
<div class="received">è¿™æ˜¯AIçš„å›å¤æ¶ˆæ¯</div>`;
      } else if (htmlStructureMode === 'bubble') {
        html = `<!-- ç”¨æˆ·æ¶ˆæ¯ -->
<div class="message-bubble sent">è¿™æ˜¯ç”¨æˆ·å‘é€çš„æ¶ˆæ¯</div>

<!-- AIæ¶ˆæ¯ -->
<div class="message-bubble received">è¿™æ˜¯AIçš„å›å¤æ¶ˆæ¯</div>`;
      }
      
      htmlStructureEl.value = html;
    }

    // å¤åˆ¶HTMLç»“æ„
    function copyHtmlStructure() {
      const htmlStructureEl = document.getElementById('htmlStructure');
      if (!htmlStructureEl) return;
      
      navigator.clipboard.writeText(htmlStructureEl.value).then(() => {
        alert('HTMLç»“æ„å·²å¤åˆ¶ï¼\næŠŠè¿™ä¸ªHTMLç»“æ„ç²˜è´´åˆ°ä½ çš„ç½‘é¡µä¸­ï¼Œç„¶ååº”ç”¨CSSå°±èƒ½çœ‹åˆ°æ•ˆæœäº†ã€‚');
      });
    }

    // ç”Ÿæˆå•ä¸ªæ°”æ³¡çš„CSS
    function generateBubbleCSS(selector, styles) {
      let css = `${selector} {\n`;
      css += '  position: relative !important;\n';
      
      Object.entries(styles).forEach(([name, data]) => {
        // backdrop-filter
        if (data.type === 'backdrop' && data.blurValue !== undefined) {
          css += `  ${name}: blur(${data.blurValue}px) !important;\n`;
        }
        // å¤šå±‚é˜´å½±
        else if (data.type === 'multishadow' && data.shadows) {
          const shadowStrs = data.shadows.map((s, idx) => {
            const x = data[`shadow${idx}X`] !== undefined ? data[`shadow${idx}X`] : s.x;
            const y = data[`shadow${idx}Y`] !== undefined ? data[`shadow${idx}Y`] : s.y;
            const blur = data[`shadow${idx}Blur`] !== undefined ? data[`shadow${idx}Blur`] : s.blur;
            const spread = data[`shadow${idx}Spread`] !== undefined ? data[`shadow${idx}Spread`] : s.spread;
            const inset = s.isInset ? 'inset ' : '';
            return `${inset}${x}px ${y}px ${blur}px ${spread}px rgba(0,0,0,0.15)`;
          });
          css += `  ${name}: ${shadowStrs.join(', ')} !important;\n`;
        }
        // æ¸å˜
        else if (data.type === 'gradient') {
          // å¦‚æœæœ‰gradientColorså±æ€§ï¼ˆæ—§æ ¼å¼ï¼‰
          if (data.gradientColors && Array.isArray(data.gradientColors)) {
            const colors = data.gradientColors.map((c, idx) => {
              const hex = data[`gradColor${idx}`] || c.hex;
              const alpha = data[`gradAlpha${idx}`] !== undefined ? data[`gradAlpha${idx}`] : c.alpha;
              const r = parseInt(hex.slice(1, 3), 16);
              const g = parseInt(hex.slice(3, 5), 16);
              const b = parseInt(hex.slice(5, 7), 16);
              return `rgba(${r}, ${g}, ${b}, ${(alpha / 100).toFixed(2)})`;
            });
            const angle = data.gradientAngle || 135;
            css += `  ${name}: linear-gradient(${angle}deg, ${colors.join(', ')}) !important;\n`;
          }
          // å¦‚æœç›´æ¥æ˜¯gradientå­—ç¬¦ä¸²ï¼ˆæ–°æ ¼å¼ï¼‰
          else if (data.value) {
            css += `  ${name}: ${data.value} !important;\n`;
          }
        }
        // æ™®é€šé¢œè‰²
        else if (data.type === 'color') {
          if (data.color === 'transparent' || data.original === 'transparent') {
            css += `  ${name}: transparent !important;\n`;
          } else if (data.color) {
            if (data.alpha !== undefined) {
              const r = parseInt(data.color.slice(1, 3), 16);
              const g = parseInt(data.color.slice(3, 5), 16);
              const b = parseInt(data.color.slice(5, 7), 16);
              const a = (data.alpha / 100).toFixed(2);
              css += `  ${name}: rgba(${r}, ${g}, ${b}, ${a}) !important;\n`;
            } else {
              css += `  ${name}: ${data.color} !important;\n`;
            }
          }
        }
        // å°ºå¯¸
        else if (data.type === 'size' && data.size !== undefined) {
          css += `  ${name}: ${data.size}px !important;\n`;
        }
        // border
        else if (data.type === 'border') {
          const width = data.borderWidth || 1;
          const color = data.borderColor || '#000000';
          const style = data.borderStyle || 'solid';
          css += `  ${name}: ${width}px ${style} ${color} !important;\n`;
        }
        // opacity
        else if (data.type === 'opacity') {
          const val = data.opacityValue !== undefined ? data.opacityValue : 100;
          css += `  ${name}: ${(val / 100).toFixed(2)} !important;\n`;
        }
        // font-weight
        else if (data.type === 'weight') {
          css += `  ${name}: ${data.weightValue || 400} !important;\n`;
        }
        // transform
        else if (data.type === 'transform') {
          const transforms = [];
          
          if (data.translateX !== undefined) {
            transforms.push(`translateX(${data.translateX}px)`);
          }
          if (data.translateY !== undefined) {
            transforms.push(`translateY(${data.translateY}px)`);
          }
          if (data.scaleValue !== undefined) {
            const scale = data.scaleValue / 100;
            transforms.push(`scale(${scale.toFixed(2)})`);
          }
          if (data.rotateValue !== undefined) {
            transforms.push(`rotate(${data.rotateValue}deg)`);
          }
          
          if (transforms.length > 0) {
            css += `  ${name}: ${transforms.join(' ')} !important;\n`;
          }
        }
        // line-height
        else if (data.type === 'lineheight') {
          const val = data.lineHeightValue !== undefined ? data.lineHeightValue : 15;
          css += `  ${name}: ${(val / 10).toFixed(1)} !important;\n`;
        }
        // z-index
        else if (data.type === 'zindex') {
          css += `  ${name}: ${data.zValue || 1} !important;\n`;
        }
        // max-width
        else if (data.type === 'maxwidth') {
          css += `  ${name}: ${data.maxWidthValue || 70}% !important;\n`;
        }
        // transition
        else if (data.type === 'transition') {
          const duration = data.transitionDuration !== undefined ? data.transitionDuration : 3;
          css += `  ${name}: all ${(duration / 10).toFixed(1)}s ease !important;\n`;
        }
        // å®šä½å±æ€§
        else if (data.type === 'position') {
          css += `  ${name}: ${data.posValue || 0}px !important;\n`;
        }
        // text-shadow
        else if (data.type === 'textshadow') {
          const x = data.textShadowX || 0;
          const y = data.textShadowY || 0;
          const blur = data.textShadowBlur || 0;
          css += `  ${name}: ${x}px ${y}px ${blur}px rgba(0,0,0,0.3) !important;\n`;
        }
        // filter
        else if (data.type === 'filter') {
          // ä½¿ç”¨originalæˆ–valueï¼Œæˆ–è€…æ„å»ºfilterå­—ç¬¦ä¸²
          if (data.original) {
            css += `  ${name}: ${data.original} !important;\n`;
          } else if (data.value) {
            css += `  ${name}: ${data.value} !important;\n`;
          } else {
            // æ—§çš„æ–¹å¼ï¼Œå…¼å®¹
            const blur = data.blur || 0;
            if (blur > 0) {
              css += `  ${name}: blur(${blur}px) !important;\n`;
            }
          }
        }
        // shadow (box-shadowå•ç‹¬å¤„ç†)
        else if (data.type === 'shadow') {
          if (data.original) {
            css += `  ${name}: ${data.original} !important;\n`;
          } else if (data.value) {
            css += `  ${name}: ${data.value} !important;\n`;
          }
        }
        // textç±»å‹ï¼ˆæ™®é€šæ–‡æœ¬å€¼ï¼‰
        else if (data.type === 'text') {
          if (data.original) {
            css += `  ${name}: ${data.original} !important;\n`;
          } else if (data.value) {
            css += `  ${name}: ${data.value} !important;\n`;
          }
        }
        // clip-path
        else if (data.type === 'clippath') {
          css += `  ${name}: ${data.value} !important;\n`;
        }
        // å…¶ä»–ä¿æŒåŸæ ·ï¼ˆä¼˜å…ˆä½¿ç”¨originalï¼Œå…¶æ¬¡valueï¼‰
        else {
          if (data.original) {
            css += `  ${name}: ${data.original} !important;\n`;
          } else if (data.value) {
            css += `  ${name}: ${data.value} !important;\n`;
          }
        }
      });
      
      css += '}\n\n';
      
      return css;
    }

    // é˜²æŠ–å®šæ—¶å™¨
    let updatePreviewTimer = null;

    // æ›´æ–°é¢„è§ˆï¼ˆå¸¦é˜²æŠ–ï¼‰
    function updatePreview() {
      // åŒæ­¥ä¿å­˜å½“å‰ç¼–è¾‘çš„æ ·å¼
      if (currentBubbleType === 'user') {
        userStyles = JSON.parse(JSON.stringify(parsedStyles));
      } else {
        aiStyles = JSON.parse(JSON.stringify(parsedStyles));
      }
      
      // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
      if (updatePreviewTimer) {
        clearTimeout(updatePreviewTimer);
      }
      
      // è®¾ç½®æ–°çš„å®šæ—¶å™¨ï¼ˆ30msé˜²æŠ–ï¼‰
      updatePreviewTimer = setTimeout(() => {
        updatePreviewFromControls();
        autoSaveCurrentState(); // è‡ªåŠ¨ä¿å­˜
      }, 30);
    }
    
    // ç«‹å³æ›´æ–°é¢„è§ˆï¼ˆä¸é˜²æŠ–ï¼‰
    function updatePreviewNow() {
      updatePreviewFromControls();
    }

    // åˆ‡æ¢æ‚¬æµ®é¢„è§ˆçª—å£
    function toggleFloatingPreview() {
      const preview = document.getElementById('floatingPreview');
      preview.classList.toggle('active');
    }

    // æ‚¬æµ®çª—æ‹–åŠ¨åŠŸèƒ½
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;

    document.addEventListener('DOMContentLoaded', () => {
      const dragHeader = document.getElementById('floatingHeader');
      const dragElement = document.getElementById('floatingPreview');

      dragHeader.addEventListener('mousedown', dragStart);
      dragHeader.addEventListener('touchstart', dragStart);

      document.addEventListener('mousemove', drag);
      document.addEventListener('touchmove', drag);

      document.addEventListener('mouseup', dragEnd);
      document.addEventListener('touchend', dragEnd);

      function dragStart(e) {
        if (e.type === 'touchstart') {
          initialX = e.touches[0].clientX - xOffset;
          initialY = e.touches[0].clientY - yOffset;
        } else {
          initialX = e.clientX - xOffset;
          initialY = e.clientY - yOffset;
        }

        if (e.target === dragHeader || dragHeader.contains(e.target)) {
          if (!e.target.classList.contains('floating-close')) {
            isDragging = true;
          }
        }
      }

      function drag(e) {
        if (isDragging) {
          e.preventDefault();
          
          if (e.type === 'touchmove') {
            currentX = e.touches[0].clientX - initialX;
            currentY = e.touches[0].clientY - initialY;
          } else {
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
          }

          xOffset = currentX;
          yOffset = currentY;

          setTranslate(currentX, currentY, dragElement);
        }
      }

      function dragEnd(e) {
        initialX = currentX;
        initialY = currentY;
        isDragging = false;
      }

      function setTranslate(xPos, yPos, el) {
        el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
      }
      
      // æ¢å¤è‡ªåŠ¨ä¿å­˜çš„æ•°æ®
      const restored = restoreFromAutoSave();
      
      // åˆå§‹åŒ–ï¼šç«‹å³æ›´æ–°é¢„è§ˆï¼Œæ˜¾ç¤ºä¸¤ä¸ªæ°”æ³¡
      setTimeout(() => {
        if (restored) {
          // å¦‚æœæ¢å¤äº†æ•°æ®ï¼Œé‡æ–°ç”Ÿæˆæ§ä»¶å’Œé¢„è§ˆ
          generateControls(parsedStyles);
          generatePseudoControls();
          updateStickerButtons();
          updatePreviewNow();
          console.log('å·²æ¢å¤ä¸Šæ¬¡ç¼–è¾‘çš„æ•°æ®');
        } else {
          // å¦åˆ™æ­£å¸¸åˆå§‹åŒ–
          updatePreviewNow();
          updateStickerButtons();
          generatePseudoControls();
        }
      }, 100);
    });

    // å¤åˆ¶CSS
    function copyCSS() {
      const css = document.getElementById('cssOutput').value;
      navigator.clipboard.writeText(css).then(() => {
        alert('CSSå·²å¤åˆ¶');
      });
    }

    // ä¿å­˜CSS
    function saveCSS() {
      const css = document.getElementById('cssOutput').value;
      localStorage.setItem('bubble_css', css);
      alert('å·²ä¿å­˜åˆ°æœ¬åœ°');
    }

    // æ˜¾ç¤ºæ·»åŠ å±æ€§å¼¹çª—
    function showAddPropertyModal() {
      document.getElementById('addPropertyModal').style.display = 'block';
    }

    // å…³é—­æ·»åŠ å±æ€§å¼¹çª—
    function closeAddPropertyModal() {
      document.getElementById('addPropertyModal').style.display = 'none';
    }

    // æ·»åŠ æ–°å±æ€§
    function addNewProperty() {
      const select = document.getElementById('newPropertySelect');
      const propName = select.value;
      
      if (!propName) {
        alert('è¯·é€‰æ‹©ä¸€ä¸ªå±æ€§ï¼');
        return;
      }

      // åˆ›å»ºé»˜è®¤å€¼
      let defaultValue = '';
      // å¸ƒå±€ç±»
      if (propName === 'display') defaultValue = 'flex';
      else if (propName === 'position') defaultValue = 'relative';
      else if (propName === 'top') defaultValue = '0px';
      else if (propName === 'left') defaultValue = '0px';
      else if (propName === 'right') defaultValue = '0px';
      else if (propName === 'bottom') defaultValue = '0px';
      else if (propName === 'z-index') defaultValue = '1';
      else if (propName === 'overflow') defaultValue = 'visible';
      else if (propName === 'max-width') defaultValue = '70%';
      else if (propName === 'width') defaultValue = '100px';
      else if (propName === 'height') defaultValue = '100px';
      // é—´è·ç±»
      else if (propName === 'padding') defaultValue = '10px';
      else if (propName === 'margin') defaultValue = '10px';
      else if (propName === 'padding-top') defaultValue = '10px';
      else if (propName === 'padding-bottom') defaultValue = '10px';
      else if (propName === 'padding-left') defaultValue = '10px';
      else if (propName === 'padding-right') defaultValue = '10px';
      // è¾¹æ¡†ç±»
      else if (propName === 'border') defaultValue = '2px solid #000000';
      else if (propName === 'border-radius') defaultValue = '10px';
      else if (propName === 'border-top') defaultValue = '2px solid #000000';
      else if (propName === 'border-bottom') defaultValue = '2px solid #000000';
      else if (propName === 'border-left') defaultValue = '2px solid #000000';
      else if (propName === 'border-right') defaultValue = '2px solid #000000';
      // èƒŒæ™¯ç±»
      else if (propName === 'background-color') defaultValue = '#ffffff';
      else if (propName === 'background') defaultValue = 'linear-gradient(135deg, #ffffff, #f0f0f0)';
      else if (propName === 'background-image') defaultValue = 'url(https://example.com/image.png)';
      else if (propName === 'background-size') defaultValue = 'cover';
      else if (propName === 'background-position') defaultValue = 'center';
      // æ–‡å­—ç±»
      else if (propName === 'color') defaultValue = '#000000';
      else if (propName === 'font-size') defaultValue = '14px';
      else if (propName === 'font-weight') defaultValue = '400';
      else if (propName === 'line-height') defaultValue = '1.5';
      else if (propName === 'text-align') defaultValue = 'left';
      else if (propName === 'word-break') defaultValue = 'break-word';
      // æ•ˆæœç±»
      else if (propName === 'box-shadow') defaultValue = '2px 2px 8px 0px rgba(0,0,0,0.15)';
      else if (propName === 'text-shadow') defaultValue = '1px 1px 2px rgba(0,0,0,0.3)';
      else if (propName === 'opacity') defaultValue = '1';
      else if (propName === 'backdrop-filter') defaultValue = 'blur(10px)';
      // åŠ¨ç”»ç±»
      else if (propName === 'transform') defaultValue = 'translateX(0px) translateY(0px) scale(1) rotate(0deg)';
      else if (propName === 'transition') defaultValue = 'all 0.3s ease';
      else if (propName === 'animation') defaultValue = 'float 2s infinite';

      // æ·»åŠ åˆ°parsedStyles
      parsedStyles[propName] = parsePropertyValue(propName, defaultValue);
      
      // æ ‡è®°ä¸ºè‡ªå®šä¹‰æ·»åŠ 
      if (!parsedStyles[propName].isCustom) {
        parsedStyles[propName].isCustom = true;
      }
      
      // åœ¨è‡ªå®šä¹‰æ§ä»¶åŒºæ˜¾ç¤º
      addCustomControl(propName, parsedStyles[propName]);
      
      // æ›´æ–°é¢„è§ˆ
      updatePreview();
      
      // å…³é—­å¼¹çª—
      closeAddPropertyModal();
      
      alert(`å·²æ·»åŠ  ${propName} å±æ€§ï¼`);
    }
    
    // æ°”æ³¡ç±»å‹åˆ‡æ¢
    let currentBubbleType = 'user'; // 'user' or 'ai'
    let userStyles = JSON.parse(JSON.stringify(parsedStyles)); // ä¿å­˜ç”¨æˆ·æ°”æ³¡æ ·å¼ï¼ˆåˆå§‹åŒ–ä¸ºå½“å‰æ ·å¼ï¼‰
    let aiStyles = {}; // ä¿å­˜AIæ°”æ³¡æ ·å¼

    // ==================== è‡ªåŠ¨ä¿å­˜å’Œæ ·å¼åº“ ====================
    
    // è‡ªåŠ¨ä¿å­˜å½“å‰ç¼–è¾‘çŠ¶æ€
    function autoSaveCurrentState() {
      const currentState = {
        userStyles: userStyles,
        aiStyles: aiStyles,
        extraCSS: extraCSS,
        currentBubbleType: currentBubbleType,
        timestamp: Date.now()
      };
      localStorage.setItem('bubble_editor_autosave', JSON.stringify(currentState));
    }
    
    // ä»è‡ªåŠ¨ä¿å­˜æ¢å¤
    function restoreFromAutoSave() {
      try {
        const saved = localStorage.getItem('bubble_editor_autosave');
        if (saved) {
          const state = JSON.parse(saved);
          userStyles = state.userStyles || {};
          aiStyles = state.aiStyles || {};
          extraCSS = state.extraCSS || { beforePseudo: '', afterPseudo: '', animations: '' };
          currentBubbleType = state.currentBubbleType || 'user';
          
          // æ¢å¤å½“å‰ç¼–è¾‘çš„æ ·å¼
          parsedStyles = JSON.parse(JSON.stringify(currentBubbleType === 'user' ? userStyles : aiStyles));
          
          return true;
        }
      } catch (e) {
        console.error('æ¢å¤è‡ªåŠ¨ä¿å­˜å¤±è´¥:', e);
      }
      return false;
    }
    
    // æ ·å¼åº“ç®¡ç†
    function getSavedStyles() {
      try {
        const saved = localStorage.getItem('bubble_styles_library');
        return saved ? JSON.parse(saved) : [];
      } catch (e) {
        return [];
      }
    }
    
    function saveStylesToLibrary(name) {
      if (!name || !name.trim()) {
        alert('è¯·è¾“å…¥æ ·å¼åç§°');
        return;
      }
      
      const styles = getSavedStyles();
      const newStyle = {
        id: Date.now().toString(),
        name: name.trim(),
        userStyles: JSON.parse(JSON.stringify(userStyles)),
        aiStyles: JSON.parse(JSON.stringify(aiStyles)),
        extraCSS: JSON.parse(JSON.stringify(extraCSS)),
        timestamp: Date.now()
      };
      
      styles.unshift(newStyle);
      localStorage.setItem('bubble_styles_library', JSON.stringify(styles));
      
      showStylesLibrary();
      alert('æ ·å¼å·²ä¿å­˜ï¼');
    }
    
    function loadStyleFromLibrary(id) {
      const styles = getSavedStyles();
      const style = styles.find(s => s.id === id);
      if (style) {
        userStyles = JSON.parse(JSON.stringify(style.userStyles));
        aiStyles = JSON.parse(JSON.stringify(style.aiStyles));
        extraCSS = JSON.parse(JSON.stringify(style.extraCSS));
        
        // æ¢å¤å½“å‰ç¼–è¾‘çš„æ ·å¼
        parsedStyles = JSON.parse(JSON.stringify(currentBubbleType === 'user' ? userStyles : aiStyles));
        
        // æ›´æ–°UI
        switchBubbleType(currentBubbleType);
        autoSaveCurrentState();
        hideStylesLibrary();
        alert('æ ·å¼å·²åŠ è½½ï¼');
      }
    }
    
    function deleteStyleFromLibrary(id) {
      if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ ·å¼å—ï¼Ÿ')) return;
      
      let styles = getSavedStyles();
      styles = styles.filter(s => s.id !== id);
      localStorage.setItem('bubble_styles_library', JSON.stringify(styles));
      showStylesLibrary();
    }
    
    function showStylesLibrary() {
      const modal = document.getElementById('stylesLibraryModal');
      const list = document.getElementById('stylesLibraryList');
      const styles = getSavedStyles();
      
      if (styles.length === 0) {
        list.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">æš‚æ— ä¿å­˜çš„æ ·å¼<br><span style="font-size:12px;">ç‚¹å‡»ä¸‹æ–¹"ä¿å­˜å½“å‰æ ·å¼"åˆ›å»ºç¬¬ä¸€ä¸ª</span></div>';
      } else {
        list.innerHTML = styles.map(style => `
          <div style="background:#f9f9f9; padding:12px; border-radius:8px; margin-bottom:10px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <div style="font-weight:500; font-size:14px;">${style.name}</div>
              <div style="font-size:11px; color:#999;">${new Date(style.timestamp).toLocaleString()}</div>
            </div>
            <div style="display:flex; gap:6px;">
              <button onclick="loadStyleFromLibrary('${style.id}')" style="flex:1; padding:6px; background:#000; color:#fff; border:none; border-radius:4px; font-size:12px; cursor:pointer;">åŠ è½½</button>
              <button onclick="deleteStyleFromLibrary('${style.id}')" style="padding:6px 12px; background:#999; color:#fff; border:none; border-radius:4px; font-size:12px; cursor:pointer;">åˆ é™¤</button>
            </div>
          </div>
        `).join('');
      }
      
      modal.style.display = 'flex';
    }
    
    function hideStylesLibrary() {
      document.getElementById('stylesLibraryModal').style.display = 'none';
    }
    
    function promptSaveStyle() {
      const name = prompt('è¯·è¾“å…¥æ ·å¼åç§°ï¼ˆå¦‚ï¼šæ¢¦å¹»ç²‰ã€ç§‘æŠ€è“ç­‰ï¼‰');
      if (name) {
        saveStylesToLibrary(name);
      }
    }

    function switchBubbleType(type) {
      // ä¿å­˜å½“å‰æ ·å¼
      if (currentBubbleType === 'user') {
        userStyles = JSON.parse(JSON.stringify(parsedStyles));
      } else {
        aiStyles = JSON.parse(JSON.stringify(parsedStyles));
      }
      
      // åˆ‡æ¢ç±»å‹
      currentBubbleType = type;
      
      // æ›´æ–°æŒ‰é’®æ ·å¼
      const userTab = document.getElementById('bubbleUserTab');
      const aiTab = document.getElementById('bubbleAiTab');
      const aiCopyTip = document.getElementById('aiCopyTip');
      
      if (type === 'user') {
        userTab.style.background = '#000';
        userTab.style.color = '#fff';
        aiTab.style.background = '#f0f0f0';
        aiTab.style.color = '#666';
        aiCopyTip.style.display = 'none';
        
        // åŠ è½½ç”¨æˆ·æ ·å¼
        parsedStyles = JSON.parse(JSON.stringify(userStyles));
      } else {
        userTab.style.background = '#f0f0f0';
        userTab.style.color = '#666';
        aiTab.style.background = '#000';
        aiTab.style.color = '#fff';
        aiCopyTip.style.display = 'block';
        
        // åŠ è½½AIæ ·å¼
        parsedStyles = JSON.parse(JSON.stringify(aiStyles));
      }
      
      // é‡æ–°ç”Ÿæˆæ§ä»¶å’Œæ›´æ–°é¢„è§ˆ
      generateControls(parsedStyles);
      generatePseudoControls(); // æ›´æ–°ä¼ªå…ƒç´ æ§ä»¶æ˜¾ç¤º
      updatePreview();
    }

    // å¤åˆ¶ç”¨æˆ·æ°”æ³¡åˆ°AIæ°”æ³¡
    function copyUserToAi() {
      if (Object.keys(userStyles).length === 0) {
        alert('ç”¨æˆ·æ°”æ³¡è¿˜æ²¡æœ‰è®¾ç½®æ ·å¼ï¼è¯·å…ˆè®¾ç½®ç”¨æˆ·æ°”æ³¡ã€‚');
        return;
      }
      
      // å¤åˆ¶ç”¨æˆ·æ ·å¼åˆ°AIæ°”æ³¡
      aiStyles = JSON.parse(JSON.stringify(userStyles));
      parsedStyles = JSON.parse(JSON.stringify(aiStyles));
      
      // é‡æ–°ç”Ÿæˆæ§ä»¶å’Œæ›´æ–°é¢„è§ˆ
      generateControls(parsedStyles);
      updatePreview();
      
      alert('å·²å¤åˆ¶ç”¨æˆ·æ°”æ³¡æ ·å¼åˆ°AIæ°”æ³¡ï¼\nç°åœ¨å¯ä»¥è¿›è¡Œå¾®è°ƒäº†ã€‚');
    }

    // æ·»åŠ è‡ªå®šä¹‰æ§ä»¶åˆ°customControlsåŒºåŸŸ
    function addCustomControl(propName, propData) {
      const container = document.getElementById('customControls');
      if (!container) return;
      
      // åˆ›å»ºæ§ä»¶å¡ç‰‡ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
      let card = container.querySelector('.card');
      if (!card) {
        card = document.createElement('div');
        card.className = 'card';
        const title = document.createElement('div');
        title.className = 'card-title';
        title.textContent = 'è‡ªå®šä¹‰å±æ€§';
        card.appendChild(title);
        container.appendChild(card);
      }
      
      // åˆ›å»ºæ§ä»¶ç»„
      const group = document.createElement('div');
      group.style.marginBottom = '12px';
      group.style.padding = '10px';
      group.style.background = '#f9f9f9';
      group.style.borderRadius = '6px';
      
      const titleDiv = document.createElement('div');
      titleDiv.style.fontWeight = '500';
      titleDiv.style.marginBottom = '8px';
      titleDiv.style.fontSize = '12px';
      titleDiv.style.display = 'flex';
      titleDiv.style.justifyContent = 'space-between';
      titleDiv.style.alignItems = 'center';
      
      const nameSpan = document.createElement('span');
      nameSpan.textContent = propName;
      titleDiv.appendChild(nameSpan);
      
      // åˆ é™¤æŒ‰é’®
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Ã—';
      delBtn.style.cssText = 'background:#999; color:#fff; border:none; border-radius:4px; width:24px; height:24px; cursor:pointer; font-size:16px; line-height:1;';
      delBtn.onclick = function() {
        if (confirm(`ç¡®å®šåˆ é™¤ ${propName} å±æ€§ï¼Ÿ`)) {
          delete parsedStyles[propName];
          group.remove();
          updatePreview();
          // å¦‚æœæ²¡æœ‰è‡ªå®šä¹‰å±æ€§äº†ï¼Œåˆ é™¤å¡ç‰‡
          if (card.children.length <= 1) {
            card.remove();
          }
        }
      };
      titleDiv.appendChild(delBtn);
      
      group.appendChild(titleDiv);
      
      // æ·»åŠ è¾“å…¥æ¡†
      const input = document.createElement('input');
      input.type = 'text';
      input.value = propData.original || '';
      input.style.cssText = 'width:100%; padding:8px; border:1px solid #e5e5e5; border-radius:6px; font-size:12px;';
      input.oninput = function() {
        parsedStyles[propName] = parsePropertyValue(propName, this.value);
        updatePreview();
      };
      group.appendChild(input);
      
      card.appendChild(group);
    }

    // èƒŒæ™¯å›¾ç›¸å…³
    let uploadedBgImage = '';

    function handleBgImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶5MBï¼‰
      if (file.size > 5 * 1024 * 1024) {
        alert('å›¾ç‰‡å¤ªå¤§ï¼è¯·é€‰æ‹©å°äº5MBçš„å›¾ç‰‡');
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        uploadedBgImage = e.target.result;
        
        // æ˜¾ç¤ºé¢„è§ˆ
        document.getElementById('bgImageThumb').src = uploadedBgImage;
        document.getElementById('bgImagePreview').style.display = 'block';
        
        console.log('èƒŒæ™¯å›¾å·²ä¸Šä¼ ï¼Œå¤§å°:', (file.size / 1024).toFixed(2), 'KB');
      };
      reader.readAsDataURL(file);
    }

    function applyBgImage() {
      if (!uploadedBgImage) {
        alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡');
        return;
      }

      // æ·»åŠ æˆ–æ›´æ–° background-image å±æ€§
      const bgImageProp = `url(${uploadedBgImage})`;
      
      // å¦‚æœå·²æœ‰ background-imageï¼Œæ›´æ–°å®ƒ
      if (parsedStyles['background-image']) {
        parsedStyles['background-image'].original = bgImageProp;
      } else {
        // å¦åˆ™æ–°å¢
        parsedStyles['background-image'] = {
          type: 'raw',
          original: bgImageProp,
          editable: []
        };
      }

      // åŒæ—¶è®¾ç½® background-size å’Œ background-repeatï¼ˆå¦‚æœæ²¡æœ‰çš„è¯ï¼‰
      if (!parsedStyles['background-size']) {
        parsedStyles['background-size'] = {
          type: 'raw',
          original: 'cover',
          editable: []
        };
      }
      if (!parsedStyles['background-repeat']) {
        parsedStyles['background-repeat'] = {
          type: 'raw',
          original: 'no-repeat',
          editable: []
        };
      }

      // åªæ›´æ–°é¢„è§ˆï¼Œä¸é‡æ–°ç”Ÿæˆæ§ä»¶ï¼ˆä¿ç•™ç°æœ‰æ§ä»¶å’Œæ•°å€¼ï¼‰
      updatePreview();
      
      alert('èƒŒæ™¯å›¾å·²åº”ç”¨ï¼å…¶ä»–å±æ€§ä¿æŒä¸å˜');
    }

    function removeBgImage() {
      uploadedBgImage = '';
      document.getElementById('bgImagePreview').style.display = 'none';
      document.getElementById('bgImageInput').value = '';
      
      // åˆ é™¤ background-image å±æ€§
      delete parsedStyles['background-image'];
      delete parsedStyles['background-size'];
      delete parsedStyles['background-repeat'];
      
      // åªæ›´æ–°é¢„è§ˆï¼Œä¸é‡æ–°ç”Ÿæˆæ§ä»¶ï¼ˆä¿ç•™å…¶ä»–æ§ä»¶å’Œæ•°å€¼ï¼‰
      updatePreview();
      
      alert('èƒŒæ™¯å›¾å·²åˆ é™¤ï¼Œå…¶ä»–å±æ€§ä¿æŒä¸å˜');
    }

    // ä¼ªå…ƒç´ å›¾ç‰‡ä¸Šä¼ ï¼ˆè´´çº¸ï¼Œå¯è¶…å‡ºæ°”æ³¡æ¡†ï¼‰
    function handlePseudoImageUpload(event, type) {
      const file = event.target.files[0];
      if (!file) return;

      // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶2MBï¼‰
      if (file.size > 2 * 1024 * 1024) {
        alert('å›¾ç‰‡å¤ªå¤§ï¼è¯·é€‰æ‹©å°äº2MBçš„å›¾ç‰‡');
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const imageData = e.target.result;
        
        const pseudoKey = type === 'before' ? 'beforePseudo' : 'afterPseudo';
        let css = extraCSS[pseudoKey];
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ content: url() æˆ– background-image: url()
        const hasContentUrl = /content:\s*url\(/i.test(css);
        const hasBgImage = /background-image:\s*url\(/i.test(css);
        
        if (hasContentUrl) {
          // å¦‚æœæœ‰ content: url()ï¼Œå…ˆåˆ é™¤å®ƒï¼Œæ”¹ç”¨background-image
          css = css.replace(/content:\s*url\([^)]+\)\s*!important;?/gi, 'content: "" !important;');
          // æ·»åŠ æˆ–æ›¿æ¢ background-image
          if (hasBgImage) {
            css = css.replace(/(background-image:\s*url\()([^)]+)(\))/gi, `$1${imageData}$3`);
          } else {
            const insertPos = css.lastIndexOf('}');
            if (insertPos > 0) {
              css = css.substring(0, insertPos) + 
                `  background-image: url(${imageData}) !important;\n` +
                `  background-size: cover !important;\n` +
                `  background-position: center !important;\n` +
                `  background-repeat: no-repeat !important;\n}`;
            }
          }
        } else if (hasBgImage) {
          // å¦‚æœåªæœ‰ background-imageï¼Œç›´æ¥æ›¿æ¢
          css = css.replace(/(background-image:\s*url\()([^)]+)(\))/gi, `$1${imageData}$3`);
        } else {
          // éƒ½æ²¡æœ‰ï¼Œæ·»åŠ èƒŒæ™¯å›¾æ–¹å¼ï¼ˆå¯è°ƒæ•´å¤§å°ï¼‰
          const insertPos = css.lastIndexOf('}');
          if (insertPos > 0) {
            css = css.substring(0, insertPos) + 
              `  content: "" !important;\n` +
              `  position: absolute !important;\n` +
              `  top: -15px !important;\n` +
              `  ${type === 'before' ? 'left' : 'right'}: -15px !important;\n` +
              `  width: 40px !important;\n` +
              `  height: 40px !important;\n` +
              `  background-image: url(${imageData}) !important;\n` +
              `  background-size: cover !important;\n` +
              `  background-position: center !important;\n` +
              `  background-repeat: no-repeat !important;\n` +
              `  pointer-events: none !important;\n` +
              `  z-index: 10 !important;\n}`;
          }
        }
        
        extraCSS[pseudoKey] = css;
        
        // åŒæ­¥æ›´æ–°pseudoPropsçš„åˆå§‹å€¼
        if (type === 'before') {
          pseudoProps.before = { size: 40, top: -15, left: -15 };
        } else {
          pseudoProps.after = { size: 40, top: -15, right: -15 };
        }
        
        generatePseudoControls();
        updatePreview();
        
        alert(`è´´çº¸å·²åº”ç”¨åˆ° ::${type}ï¼ˆå¯è¶…å‡ºæ°”æ³¡æ¡†ï¼‰\nç°åœ¨å¯ä»¥ç”¨æ»‘å—è°ƒæ•´å¤§å°å’Œä½ç½®`);
      };
      reader.readAsDataURL(file);
    }

    // ä¼ªå…ƒç´ å±æ€§å­˜å‚¨ï¼ˆé»˜è®¤åœ¨æ°”æ³¡è§’è½ï¼‰
    let pseudoProps = {
      before: { size: 40, top: -15, left: -15 },
      after: { size: 40, top: -15, right: -15 }
    };

    // æ›´æ–°ä¼ªå…ƒç´ CSS
    function updatePseudoCSS(type) {
      const pseudoKey = type === 'before' ? 'beforePseudo' : 'afterPseudo';
      let css = extraCSS[pseudoKey];
      
      if (!css) {
        console.error('CSSä¸å­˜åœ¨:', type);
        return;
      }
      
      const props = pseudoProps[type];
      
      // æ›¿æ¢æˆ–æ·»åŠ å®½åº¦ï¼ˆä½¿ç”¨sizeï¼Œä¿ç•™!importantï¼‰
      if (/width\s*:\s*\d+px/i.test(css)) {
        css = css.replace(/width\s*:\s*\d+px(\s*!important)?/gi, `width: ${props.size}px$1`);
      } else {
        css = css.replace(/}(\s*)$/, `  width: ${props.size}px !important;\n}$1`);
      }
      
      // æ›¿æ¢æˆ–æ·»åŠ é«˜åº¦ï¼ˆä½¿ç”¨sizeï¼Œä¿ç•™!importantï¼‰
      if (/height\s*:\s*\d+px/i.test(css)) {
        css = css.replace(/height\s*:\s*\d+px(\s*!important)?/gi, `height: ${props.size}px$1`);
      } else {
        css = css.replace(/}(\s*)$/, `  height: ${props.size}px !important;\n}$1`);
      }
      
      // æ›¿æ¢æˆ–æ·»åŠ topï¼ˆä¿ç•™!importantï¼‰
      if (/top\s*:\s*-?\d+px/i.test(css)) {
        css = css.replace(/top\s*:\s*-?\d+px(\s*!important)?/gi, `top: ${props.top}px$1`);
      } else {
        css = css.replace(/}(\s*)$/, `  top: ${props.top}px !important;\n}$1`);
      }
      
      // æ›¿æ¢æˆ–æ·»åŠ left/rightï¼ˆä¿ç•™!importantï¼‰
      if (type === 'before') {
        if (/left\s*:\s*-?\d+px/i.test(css)) {
          css = css.replace(/left\s*:\s*-?\d+px(\s*!important)?/gi, `left: ${props.left}px$1`);
        } else {
          css = css.replace(/}(\s*)$/, `  left: ${props.left}px !important;\n}$1`);
        }
      } else {
        if (/right\s*:\s*-?\d+px/i.test(css)) {
          css = css.replace(/right\s*:\s*-?\d+px(\s*!important)?/gi, `right: ${props.right}px$1`);
        } else {
          css = css.replace(/}(\s*)$/, `  right: ${props.right}px !important;\n}$1`);
        }
      }
      
      extraCSS[pseudoKey] = css;
      
      // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨é˜²æŠ–æ›´æ–°é¢„è§ˆ
      clearTimeout(window.pseudoUpdateTimer);
      window.pseudoUpdateTimer = setTimeout(() => {
        updatePreview();
      }, 50);
      
      // åŒæ­¥æ›´æ–°textareaæ˜¾ç¤ºï¼ˆä¸é‡æ–°ç”Ÿæˆæ§ä»¶ï¼Œé¿å…å¤±ç„¦ï¼‰
      const textareaId = type === 'before' ? 'beforeTextarea' : 'afterTextarea';
      const textarea = document.getElementById(textareaId);
      if (textarea) {
        textarea.value = css;
      }
    }

    // å½¢çŠ¶é¢„è®¾ï¼ˆä½¿ç”¨CSS clip-pathï¼‰
    const shapePresets = {
      'default': null,  // ä½¿ç”¨border-radius
      'circle': 'circle(50% at 50% 50%)',
      'ellipse': 'ellipse(50% 40% at 50% 50%)',
      'triangle': 'polygon(50% 0%, 0% 100%, 100% 100%)',
      'pentagon': 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)',
      'hexagon': 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)',
      'octagon': 'polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)',
      'star': 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
      'heart': 'polygon(50% 15%, 61% 6%, 72% 4%, 82% 8%, 88% 17%, 91% 28%, 91% 39%, 88% 50%, 50% 95%, 12% 50%, 9% 39%, 9% 28%, 12% 17%, 18% 8%, 28% 4%, 39% 6%)',
      'speech': 'polygon(0% 0%, 100% 0%, 100% 75%, 75% 75%, 70% 90%, 65% 75%, 0% 75%)',
      'custom': null  // ç”¨æˆ·è‡ªå®šä¹‰
    };

    // åˆ‡æ¢å½¢çŠ¶ç±»å‹
    function changeShapeType(type) {
      const customEditor = document.getElementById('customShapeEditor');
      const radiusControl = document.getElementById('radiusControl');
      
      // æ§åˆ¶è‡ªå®šä¹‰ç¼–è¾‘å™¨å’Œåœ†è§’æ§åˆ¶çš„æ˜¾ç¤º
      if (type === 'custom') {
        customEditor.style.display = 'block';
        radiusControl.style.display = 'none';
        
        // åˆå§‹åŒ–ç”»å¸ƒ
        setTimeout(() => {
          initShapeCanvas();
        }, 100);
      } else {
        customEditor.style.display = 'none';
        radiusControl.style.display = type === 'default' ? 'block' : 'none';
      }
      
      // åº”ç”¨å½¢çŠ¶
      if (type === 'default') {
        // åˆ é™¤clip-pathï¼Œä½¿ç”¨border-radius
        delete parsedStyles['clip-path'];
      } else if (type !== 'custom') {
        // åº”ç”¨é¢„è®¾å½¢çŠ¶
        const clipPath = shapePresets[type];
        if (clipPath) {
          parsedStyles['clip-path'] = { 
            type: 'clippath', 
            value: clipPath, 
            original: clipPath 
          };
        }
      }
      
      updatePreview();
    }

    // å¯è§†åŒ–ç”»æ¿ - å­˜å‚¨ç‚¹å‡»çš„ç‚¹
    let shapePoints = [];
    let canvas = null;
    let ctx = null;
    let drawMode = 'straight'; // 'straight' æˆ– 'curve'

    // åˆå§‹åŒ–ç”»å¸ƒ
    function initShapeCanvas() {
      canvas = document.getElementById('shapeCanvas');
      if (!canvas) return;
      
      ctx = canvas.getContext('2d');
      
      // ç‚¹å‡»ç”»å¸ƒæ·»åŠ ç‚¹ï¼ˆæ”¯æŒè§¦æ‘¸ï¼‰
      const handleAddPoint = (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        let x, y;
        
        if (e.touches) {
          // è§¦æ‘¸äº‹ä»¶
          x = e.touches[0].clientX - rect.left;
          y = e.touches[0].clientY - rect.top;
        } else {
          // é¼ æ ‡äº‹ä»¶
          x = e.clientX - rect.left;
          y = e.clientY - rect.top;
        }
        
        // è½¬æ¢ä¸ºç™¾åˆ†æ¯”
        const xPercent = Math.round((x / canvas.width) * 100);
        const yPercent = Math.round((y / canvas.height) * 100);
        
        shapePoints.push({ x: xPercent, y: yPercent, px: x, py: y });
        drawShapeCanvas();
      };
      
      canvas.addEventListener('click', handleAddPoint);
      canvas.addEventListener('touchend', handleAddPoint);
      
      drawShapeCanvas();
    }

    // åˆ‡æ¢ç»˜åˆ¶æ¨¡å¼
    function setDrawMode(mode) {
      drawMode = mode;
      
      const straightBtn = document.getElementById('straightModeBtn');
      const curveBtn = document.getElementById('curveModeBtn');
      
      if (mode === 'straight') {
        straightBtn.style.background = '#000';
        straightBtn.style.color = '#fff';
        curveBtn.style.background = '#f0f0f0';
        curveBtn.style.color = '#666';
      } else {
        straightBtn.style.background = '#f0f0f0';
        straightBtn.style.color = '#666';
        curveBtn.style.background = '#000';
        curveBtn.style.color = '#fff';
      }
      
      drawShapeCanvas();
    }

    // ç»˜åˆ¶ç”»å¸ƒ
    function drawShapeCanvas() {
      if (!ctx) return;
      
      // æ¸…ç©ºç”»å¸ƒ
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // ç»˜åˆ¶ç½‘æ ¼ï¼ˆæ·¡åŒ–ï¼‰
      ctx.strokeStyle = '#f5f5f5';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const pos = (canvas.width / 10) * i;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(canvas.width, pos);
        ctx.stroke();
      }
      
      // ç»˜åˆ¶ä¸­å¿ƒåå­—çº¿
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(centerX, 0);
      ctx.lineTo(centerX, canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(canvas.width, centerY);
      ctx.stroke();
      ctx.setLineDash([]);
      
      if (shapePoints.length === 0) return;
      
      // ç»˜åˆ¶å½¢çŠ¶
      ctx.fillStyle = 'rgba(0, 123, 255, 0.1)';
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      
      ctx.beginPath();
      ctx.moveTo(shapePoints[0].px, shapePoints[0].py);
      
      if (drawMode === 'curve' && shapePoints.length >= 3) {
        // æ›²çº¿æ¨¡å¼ï¼šä½¿ç”¨å¹³æ»‘æ›²çº¿è¿æ¥ç‚¹
        drawSmoothCurve(ctx, shapePoints);
      } else {
        // ç›´çº¿æ¨¡å¼ï¼šç›´æ¥è¿æ¥ç‚¹
        for (let i = 1; i < shapePoints.length; i++) {
          ctx.lineTo(shapePoints[i].px, shapePoints[i].py);
        }
      }
      
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // ç»˜åˆ¶æ§åˆ¶ç‚¹
      shapePoints.forEach((point, index) => {
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(point.px, point.py, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // ç»˜åˆ¶ç‚¹çš„åºå·
        ctx.fillStyle = '#fff';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(index + 1, point.px, point.py);
      });
    }

    // ç»˜åˆ¶å¹³æ»‘æ›²çº¿
    function drawSmoothCurve(ctx, points) {
      if (points.length < 3) {
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].px, points[i].py);
        }
        return;
      }
      
      // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿å¹³æ»‘è¿æ¥æ¯ä¸¤ä¸ªç‚¹
      for (let i = 0; i < points.length; i++) {
        const current = points[i];
        const next = points[(i + 1) % points.length];
        
        // æ§åˆ¶ç‚¹åœ¨å½“å‰ç‚¹å’Œä¸‹ä¸€ç‚¹ä¹‹é—´
        const cpx = (current.px + next.px) / 2;
        const cpy = (current.py + next.py) / 2;
        
        if (i === 0) {
          ctx.moveTo(current.px, current.py);
        }
        
        // ä»å½“å‰ç‚¹åˆ°ä¸­ç‚¹ç”»æ›²çº¿
        ctx.quadraticCurveTo(current.px, current.py, cpx, cpy);
        
        // å¦‚æœæ˜¯æœ€åä¸€ä¸ªç‚¹ï¼Œè¿å›èµ·ç‚¹
        if (i === points.length - 1) {
          const first = points[0];
          const lastCpx = (next.px + first.px) / 2;
          const lastCpy = (next.py + first.py) / 2;
          ctx.quadraticCurveTo(next.px, next.py, lastCpx, lastCpy);
          ctx.quadraticCurveTo(first.px, first.py, points[0].px, points[0].py);
        }
      }
    }

    // æ¸…ç©ºæ‰€æœ‰ç‚¹
    function clearShapePoints() {
      shapePoints = [];
      drawShapeCanvas();
    }

    // æ’¤é”€æœ€åä¸€ä¸ªç‚¹
    function undoLastPoint() {
      if (shapePoints.length > 0) {
        shapePoints.pop();
        drawShapeCanvas();
      }
    }

    // åº”ç”¨ç»˜åˆ¶çš„å½¢çŠ¶
    function applyDrawnShape() {
      if (shapePoints.length < 3) {
        alert('è‡³å°‘éœ€è¦3ä¸ªç‚¹æ‰èƒ½å½¢æˆå¤šè¾¹å½¢ï¼');
        return;
      }
      
      let finalPoints = [];
      
      if (drawMode === 'curve' && shapePoints.length >= 3) {
        // æ›²çº¿æ¨¡å¼ï¼šç”Ÿæˆå¯†é›†çš„æ’å€¼ç‚¹æ¥æ¨¡æ‹Ÿå¹³æ»‘æ›²çº¿
        finalPoints = generateCurvePoints(shapePoints);
      } else {
        // ç›´çº¿æ¨¡å¼ï¼šç›´æ¥ä½¿ç”¨åŸå§‹ç‚¹
        finalPoints = shapePoints;
      }
      
      // è½¬æ¢ä¸ºCSSåæ ‡æ ¼å¼
      const coords = finalPoints.map(p => `${p.x}% ${p.y}%`).join(', ');
      
      const clipPath = `polygon(${coords})`;
      parsedStyles['clip-path'] = { 
        type: 'clippath', 
        value: clipPath, 
        original: clipPath 
      };
      
      updatePreview();
      
      const modeText = drawMode === 'curve' ? 'æ›²çº¿' : 'ç›´çº¿';
      alert(`${modeText}å½¢çŠ¶å·²åº”ç”¨ï¼\næ§åˆ¶ç‚¹ï¼š${shapePoints.length}ä¸ª\nCSSç‚¹ï¼š${finalPoints.length}ä¸ª`);
    }

    // ç”Ÿæˆæ›²çº¿çš„å¯†é›†ç‚¹ï¼ˆç”¨äºCSS polygonï¼‰
    function generateCurvePoints(controlPoints) {
      const curvePoints = [];
      const segments = 20; // æ¯ä¸¤ä¸ªæ§åˆ¶ç‚¹ä¹‹é—´ç”Ÿæˆ20ä¸ªç‚¹
      
      for (let i = 0; i < controlPoints.length; i++) {
        const p0 = controlPoints[i];
        const p1 = controlPoints[(i + 1) % controlPoints.length];
        const p2 = controlPoints[(i + 2) % controlPoints.length];
        
        // åœ¨p0åˆ°p1ä¹‹é—´æ’å€¼
        for (let t = 0; t < segments; t++) {
          const ratio = t / segments;
          
          // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ’å€¼
          const cx = p1.x; // æ§åˆ¶ç‚¹åœ¨p1ä½ç½®
          const cy = p1.y;
          
          // è´å¡å°”å…¬å¼ï¼šB(t) = (1-t)Â²P0 + 2(1-t)tC + tÂ²P1
          const x = Math.round(
            (1 - ratio) * (1 - ratio) * p0.x +
            2 * (1 - ratio) * ratio * cx +
            ratio * ratio * p1.x
          );
          
          const y = Math.round(
            (1 - ratio) * (1 - ratio) * p0.y +
            2 * (1 - ratio) * ratio * cy +
            ratio * ratio * p1.y
          );
          
          curvePoints.push({ x, y });
        }
      }
      
      return curvePoints;
    }

    // åº”ç”¨è‡ªå®šä¹‰å¤šè¾¹å½¢ï¼ˆä»æ–‡æœ¬è¾“å…¥ï¼‰
    function applyCustomShape(coords) {
      if (!coords || coords.trim() === '') {
        return;
      }
      
      const clipPath = `polygon(${coords})`;
      parsedStyles['clip-path'] = { 
        type: 'clippath', 
        value: clipPath, 
        original: clipPath 
      };
      
      // è¾“å…¥æ—¶é˜²æŠ–æ›´æ–°
      clearTimeout(window.customShapeTimer);
      window.customShapeTimer = setTimeout(() => {
        updatePreview();
      }, 300);
    }

    // å¸¸ç”¨å½¢çŠ¶åº“
    const quickShapes = {
      'ä¸‰è§’å½¢': '50% 0%, 0% 100%, 100% 100%',
      'æ¢¯å½¢': '30% 0%, 70% 0%, 100% 100%, 0% 100%',
      'è±å½¢': '50% 0%, 100% 50%, 50% 100%, 0% 50%',
      'äº”è§’æ˜Ÿï¼ˆç®€åŒ–ï¼‰': '50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%',
      'ç®­å¤´â†’': '0% 30%, 60% 30%, 60% 0%, 100% 50%, 60% 100%, 60% 70%, 0% 70%',
      'å¿ƒå½¢': '50% 15%, 61% 6%, 72% 4%, 82% 8%, 88% 17%, 91% 28%, 91% 39%, 88% 50%, 50% 95%, 12% 50%, 9% 39%, 9% 28%, 12% 17%, 18% 8%, 28% 4%, 39% 6%',
      'å¯¹è¯æ¡†': '10% 0%, 90% 0%, 90% 70%, 50% 70%, 45% 85%, 40% 70%, 10% 70%, 10% 0%',
      'æ³¢æµªè¾¹': '0% 20%, 10% 10%, 20% 15%, 30% 5%, 40% 10%, 50% 0%, 60% 10%, 70% 5%, 80% 15%, 90% 10%, 100% 20%, 100% 100%, 0% 100%'
    };

    // æ˜¾ç¤ºå½¢çŠ¶ç¤ºä¾‹
    function showShapeExamples() {
      const shapeNames = Object.keys(quickShapes);
      let message = 'é€‰æ‹©è¦åŠ è½½çš„å½¢çŠ¶ï¼š\n\n';
      
      shapeNames.forEach((name, index) => {
        message += `${index + 1}. ${name}\n`;
      });
      
      message += '\nè¾“å…¥æ•°å­—ï¼ˆ1-' + shapeNames.length + 'ï¼‰é€‰æ‹©å½¢çŠ¶ï¼Œæˆ–ç‚¹å‡»å–æ¶ˆ';
      
      const input = prompt(message);
      
      if (input) {
        const index = parseInt(input) - 1;
        if (index >= 0 && index < shapeNames.length) {
          const shapeName = shapeNames[index];
          const coords = quickShapes[shapeName];
          
          // è§£æåæ ‡å¹¶åŠ è½½åˆ°ç”»æ¿
          loadShapeToCanvas(coords);
          
          alert(`å·²åŠ è½½"${shapeName}"åˆ°ç”»æ¿ï¼\nä½ å¯ä»¥ç»§ç»­è°ƒæ•´ï¼Œæˆ–ç›´æ¥ç‚¹å‡»"åº”ç”¨å½¢çŠ¶"`);
        } else {
          alert('è¾“å…¥çš„æ•°å­—æ— æ•ˆï¼');
        }
      }
    }

    // åŠ è½½å½¢çŠ¶åˆ°ç”»æ¿
    function loadShapeToCanvas(coordsString) {
      // æ¸…ç©ºç°æœ‰ç‚¹
      shapePoints = [];
      
      if (!canvas || !ctx) {
        initShapeCanvas();
      }
      
      // è§£æåæ ‡å­—ç¬¦ä¸²ï¼šæ ¼å¼ "50% 0%, 0% 100%, 100% 100%"
      // å…ˆæŒ‰ ", " åˆ†å‰²å‡ºæ¯ä¸ªç‚¹å¯¹
      const pointPairs = coordsString.split(',').map(s => s.trim());
      
      for (let i = 0; i < pointPairs.length; i++) {
        const pair = pointPairs[i].trim();
        // å†æŒ‰ç©ºæ ¼åˆ†å‰²xå’Œy
        const parts = pair.split(/\s+/);
        
        if (parts.length >= 2) {
          const xPercent = parseInt(parts[0].replace(/%/g, ''));
          const yPercent = parseInt(parts[1].replace(/%/g, ''));
          
          if (!isNaN(xPercent) && !isNaN(yPercent)) {
            // è½¬æ¢ä¸ºç”»å¸ƒåƒç´ åæ ‡
            const px = (xPercent / 100) * canvas.width;
            const py = (yPercent / 100) * canvas.height;
            
            shapePoints.push({ x: xPercent, y: yPercent, px: px, py: py });
          }
        }
      }
      
      drawShapeCanvas();
    }

    // æ›´æ–°åœ†è§’
    function updateShapeRadius(value) {
      document.getElementById('shape-radius-val').textContent = value + 'px';
      if (!parsedStyles['border-radius']) {
        parsedStyles['border-radius'] = { type: 'size', value: parseInt(value), original: value + 'px' };
      } else {
        parsedStyles['border-radius'].value = parseInt(value);
        parsedStyles['border-radius'].original = value + 'px';
      }
      
      clearTimeout(window.shapeUpdateTimer);
      window.shapeUpdateTimer = setTimeout(() => {
        updatePreview();
      }, 50);
    }

    // è¾¹ç¼˜ç¾½åŒ–ï¼ˆçœŸæ­£çš„è½¯è¾¹ç¼˜æ•ˆæœï¼‰
    function updateEdgeSoft(value) {
      const valElement = document.getElementById('edge-soft-val');
      if (valElement) valElement.textContent = value + 'px';
      
      if (value > 0) {
        // ä½¿ç”¨ filter: blur() + è½»å¾®çš„brightness å®ç°çœŸæ­£çš„è½¯è¾¹ç¼˜
        // è¿™æ ·å¯ä»¥è®©è¾¹ç¼˜è‡ªç„¶ç¾½åŒ–ï¼Œè€Œä¸æ˜¯ç¡¬æˆªæ–­
        const blurValue = Math.min(value * 0.8, 20); // æ¨¡ç³Šå¼ºåº¦
        const brightnessValue = Math.max(1 - (value * 0.02), 0.85); // è½»å¾®è°ƒæš—è¾¹ç¼˜
        
        // ç»„åˆç°æœ‰çš„filteræ•ˆæœ
        let filterParts = [];
        if (parsedStyles['filter'] && parsedStyles['filter'].dropShadow) {
          filterParts.push(parsedStyles['filter'].dropShadow);
        }
        
        // æ·»åŠ è¾¹ç¼˜ç¾½åŒ–æ•ˆæœ
        filterParts.push(`blur(${blurValue}px)`);
        filterParts.push(`brightness(${brightnessValue.toFixed(2)})`);
        
        const filterValue = filterParts.join(' ');
        
        if (!parsedStyles['filter']) {
          parsedStyles['filter'] = { 
            type: 'filter',
            edgeBlur: true,
            blurValue: blurValue,
            brightnessValue: brightnessValue,
            original: filterValue,
            value: filterValue
          };
        } else {
          parsedStyles['filter'].edgeBlur = true;
          parsedStyles['filter'].blurValue = blurValue;
          parsedStyles['filter'].brightnessValue = brightnessValue;
          parsedStyles['filter'].original = filterValue;
          parsedStyles['filter'].value = filterValue;
        }
      } else {
        // ç§»é™¤è¾¹ç¼˜ç¾½åŒ–æ•ˆæœ
        if (parsedStyles['filter'] && parsedStyles['filter'].edgeBlur) {
          // ä¿ç•™å…¶ä»–filteræ•ˆæœï¼ˆæ¯”å¦‚drop-shadowï¼‰
          let filterParts = [];
          if (parsedStyles['filter'].dropShadow) {
            filterParts.push(parsedStyles['filter'].dropShadow);
          }
          
          if (filterParts.length > 0) {
            const filterValue = filterParts.join(' ');
            parsedStyles['filter'].original = filterValue;
            parsedStyles['filter'].value = filterValue;
            delete parsedStyles['filter'].edgeBlur;
            delete parsedStyles['filter'].blurValue;
            delete parsedStyles['filter'].brightnessValue;
          } else {
            delete parsedStyles['filter'];
          }
        }
      }
      
      updatePreview();
    }

    // æ›´æ–°é€æ˜åº¦
    function updateShapeOpacity(value) {
      const percent = value;
      document.getElementById('shape-opacity-val').textContent = percent + '%';
      if (!parsedStyles['opacity']) {
        parsedStyles['opacity'] = { type: 'opacity', value: parseFloat(value / 100), original: (value / 100).toFixed(2) };
      } else {
        parsedStyles['opacity'].value = parseFloat(value / 100);
        parsedStyles['opacity'].original = (value / 100).toFixed(2);
      }
      
      clearTimeout(window.shapeUpdateTimer);
      window.shapeUpdateTimer = setTimeout(() => {
        updatePreview();
      }, 50);
    }

    // æ›´æ–°Z-Indexå±‚çº§
    function updateZIndex(value) {
      document.getElementById('zindex-val').textContent = value;
      if (!parsedStyles['z-index']) {
        parsedStyles['z-index'] = { type: 'number', value: parseInt(value), original: value };
      } else {
        parsedStyles['z-index'].value = parseInt(value);
        parsedStyles['z-index'].original = value;
      }
      updatePreview();
    }

    // æ›´æ–°å®šä½æ–¹å¼
    function updatePosition(value) {
      if (!parsedStyles['position']) {
        parsedStyles['position'] = { type: 'select', value: value, original: value };
      } else {
        parsedStyles['position'].value = value;
        parsedStyles['position'].original = value;
      }
      updatePreview();
    }

    // å¤–å‘å…‰æ•ˆæœå­˜å‚¨
    let outerGlowSettings = { size: 0, color: '#ffffff' };

    // æ›´æ–°å¤–å‘å…‰
    function updateOuterGlow(size) {
      const valElement = document.getElementById('outer-glow-val');
      const colorElement = document.getElementById('outerGlowColor');
      
      // å¦‚æœä¼ å…¥äº†sizeå‚æ•°ï¼ˆæ»‘å—è°ƒç”¨ï¼‰ï¼Œæ›´æ–°size
      if (size !== undefined && size !== null && size !== '') {
        outerGlowSettings.size = parseInt(size);
        if (valElement) valElement.textContent = size + 'px';
      }
      
      // æ›´æ–°é¢œè‰²ï¼ˆæ€»æ˜¯ä»é€‰æ‹©å™¨è¯»å–ï¼‰
      if (colorElement) {
        outerGlowSettings.color = colorElement.value;
      }
      
      // ä½¿ç”¨ä¿å­˜çš„sizeï¼Œé˜²æ­¢é¢œè‰²æ›´æ–°æ—¶sizeä¸¢å¤±
      const actualSize = outerGlowSettings.size;
      
      // æ›´æ–°æ˜¾ç¤ºå€¼
      if (valElement && !size) {
        valElement.textContent = actualSize + 'px';
      }
      
      if (actualSize > 0) {
        // å¤–å‘å…‰ç‰¹å¾ï¼šéinsetçš„ 0 0 Xpx é¢œè‰²
        const shadow = `0 0 ${actualSize}px ${outerGlowSettings.color}`;
        if (!parsedStyles['box-shadow']) {
          parsedStyles['box-shadow'] = { type: 'text', value: shadow, original: shadow };
        } else {
          // åˆå¹¶å¤šä¸ªé˜´å½±
          let existingShadow = parsedStyles['box-shadow'].original || parsedStyles['box-shadow'].value || '';
          // ç§»é™¤æ—§çš„å¤–å‘å…‰ï¼ˆç‰¹å¾ï¼šéinsetçš„ 0 0ï¼‰
          existingShadow = existingShadow.replace(/(?<!inset\s+)0\s+0\s+\d+px\s+[#\w(),.]+,?\s*/g, '').trim();
          if (existingShadow.endsWith(',')) existingShadow = existingShadow.slice(0, -1);
          if (existingShadow.startsWith(',')) existingShadow = existingShadow.slice(1).trim();
          
          parsedStyles['box-shadow'].original = existingShadow ? `${existingShadow}, ${shadow}` : shadow;
          parsedStyles['box-shadow'].value = parsedStyles['box-shadow'].original;
        }
      } else {
        if (parsedStyles['box-shadow']) {
          let existingShadow = parsedStyles['box-shadow'].original || parsedStyles['box-shadow'].value || '';
          existingShadow = existingShadow.replace(/(?<!inset\s+)0\s+0\s+\d+px\s+[#\w(),.]+,?\s*/g, '').trim();
          if (existingShadow.endsWith(',')) existingShadow = existingShadow.slice(0, -1);
          if (existingShadow.startsWith(',')) existingShadow = existingShadow.slice(1).trim();
          
          if (existingShadow) {
            parsedStyles['box-shadow'].original = existingShadow;
            parsedStyles['box-shadow'].value = existingShadow;
          } else {
            delete parsedStyles['box-shadow'];
          }
        }
      }
      updatePreview();
    }

    // å†…å‘å…‰æ•ˆæœå­˜å‚¨
    let innerGlowSettings = { size: 0, color: '#ffffff' };

    // æ›´æ–°å†…å‘å…‰ï¼ˆä½¿ç”¨inset box-shadowï¼‰
    function updateInnerGlow(size) {
      const valElement = document.getElementById('inner-glow-val');
      const colorElement = document.getElementById('innerGlowColor');
      
      // å¦‚æœä¼ å…¥äº†sizeå‚æ•°ï¼ˆæ»‘å—è°ƒç”¨ï¼‰ï¼Œæ›´æ–°size
      if (size !== undefined && size !== null && size !== '') {
        innerGlowSettings.size = parseInt(size);
        if (valElement) valElement.textContent = size + 'px';
      }
      
      // æ›´æ–°é¢œè‰²ï¼ˆæ€»æ˜¯ä»é€‰æ‹©å™¨è¯»å–ï¼‰
      if (colorElement) {
        innerGlowSettings.color = colorElement.value;
      }
      
      // ä½¿ç”¨ä¿å­˜çš„sizeï¼Œé˜²æ­¢é¢œè‰²æ›´æ–°æ—¶sizeä¸¢å¤±
      const actualSize = innerGlowSettings.size;
      
      // æ›´æ–°æ˜¾ç¤ºå€¼
      if (valElement && !size) {
        valElement.textContent = actualSize + 'px';
      }
      
      if (actualSize > 0) {
        // å†…å‘å…‰ç‰¹å¾ï¼šinset 0 0 Xpx é¢œè‰²ï¼ˆå•å±‚ï¼‰
        const shadow = `inset 0 0 ${actualSize}px ${innerGlowSettings.color}`;
        if (!parsedStyles['box-shadow']) {
          parsedStyles['box-shadow'] = { type: 'text', value: shadow, original: shadow };
        } else {
          let existingShadow = parsedStyles['box-shadow'].original || parsedStyles['box-shadow'].value || '';
          // ç§»é™¤æ—§çš„å†…å‘å…‰ï¼ˆç‰¹å¾ï¼šinset 0 0ï¼Œä½†ä¸æ˜¯è¾¹ç¼˜æŸ”åŒ–çš„åŒå±‚ï¼‰
          // å†…å‘å…‰æ˜¯å•å±‚çš„ inset 0 0
          existingShadow = existingShadow.split(',').map(s => s.trim()).filter(s => {
            // ä¿ç•™ï¼šä¸æ˜¯å•å±‚ inset 0 0 çš„é˜´å½±
            return !(s.match(/^inset\s+0\s+0\s+\d+px\s+[#\w(),.]+$/) && !s.includes(','));
          }).join(', ');
          
          if (existingShadow.endsWith(',')) existingShadow = existingShadow.slice(0, -1);
          if (existingShadow.startsWith(',')) existingShadow = existingShadow.slice(1).trim();
          
          parsedStyles['box-shadow'].original = existingShadow ? `${existingShadow}, ${shadow}` : shadow;
          parsedStyles['box-shadow'].value = parsedStyles['box-shadow'].original;
        }
      } else {
        if (parsedStyles['box-shadow']) {
          let existingShadow = parsedStyles['box-shadow'].original || parsedStyles['box-shadow'].value || '';
          existingShadow = existingShadow.split(',').map(s => s.trim()).filter(s => {
            return !(s.match(/^inset\s+0\s+0\s+\d+px\s+[#\w(),.]+$/) && !s.includes(','));
          }).join(', ');
          
          if (existingShadow.endsWith(',')) existingShadow = existingShadow.slice(0, -1);
          if (existingShadow.startsWith(',')) existingShadow = existingShadow.slice(1).trim();
          
          if (existingShadow) {
            parsedStyles['box-shadow'].original = existingShadow;
            parsedStyles['box-shadow'].value = existingShadow;
          } else {
            delete parsedStyles['box-shadow'];
          }
        }
      }
      updatePreview();
    }

    // åº”ç”¨æ–œé¢ä¸æµ®é›•æ•ˆæœ
    let currentBevelType = 'none'; // è·Ÿè¸ªå½“å‰æ–œé¢ç±»å‹
    
    function applyBevel(type) {
      // å¦‚æœç‚¹å‡»åŒä¸€ä¸ªæŒ‰é’®ï¼Œç›´æ¥è¿”å›
      if (currentBevelType === type) {
        return;
      }
      
      // ç§»é™¤æ—§çš„æ–œé¢æ•ˆæœï¼ˆä½¿ç”¨æ›´ç²¾ç¡®çš„åŒ¹é…ï¼‰
      const removeBevel = (shadowStr) => {
        if (!shadowStr) return '';
        // åˆ†å‰²æˆå•ä¸ªé˜´å½±
        const shadows = shadowStr.split(',').map(s => s.trim());
        // è¿‡æ»¤æ‰æ–œé¢ç‰¹å¾çš„é˜´å½±
        const filtered = shadows.filter(shadow => {
          // ç§»é™¤å‡¸èµ·æ•ˆæœçš„é˜´å½±
          if (shadow.includes('2px 2px 4px rgba(0, 0, 0, 0.3)')) return false;
          if (shadow.includes('-1px -1px 2px rgba(255, 255, 255, 0.5)')) return false;
          // ç§»é™¤å‡¹é™·æ•ˆæœçš„é˜´å½±
          if (shadow.includes('inset 2px 2px 4px rgba(0, 0, 0, 0.3)')) return false;
          if (shadow.includes('inset -1px -1px 2px rgba(255, 255, 255, 0.3)')) return false;
          return true;
        });
        return filtered.join(', ');
      };
      
      if (type === 'none') {
        // ç§»é™¤æ–œé¢æ•ˆæœ
        if (parsedStyles['box-shadow']) {
          let existingShadow = removeBevel(parsedStyles['box-shadow'].original || parsedStyles['box-shadow'].value);
          if (existingShadow) {
            parsedStyles['box-shadow'].original = existingShadow;
            parsedStyles['box-shadow'].value = existingShadow;
          } else {
            delete parsedStyles['box-shadow'];
          }
        }
        currentBevelType = 'none';
      } else if (type === 'raised') {
        // å‡¸èµ·æ•ˆæœï¼šå³ä¸‹æ·±è‰²ï¼Œå·¦ä¸Šæµ…è‰²
        const bevelShadow = '2px 2px 4px rgba(0, 0, 0, 0.3), -1px -1px 2px rgba(255, 255, 255, 0.5)';
        if (!parsedStyles['box-shadow']) {
          parsedStyles['box-shadow'] = { type: 'shadow', value: bevelShadow, original: bevelShadow };
        } else {
          let existingShadow = removeBevel(parsedStyles['box-shadow'].original || parsedStyles['box-shadow'].value);
          parsedStyles['box-shadow'].original = existingShadow ? `${existingShadow}, ${bevelShadow}` : bevelShadow;
          parsedStyles['box-shadow'].value = parsedStyles['box-shadow'].original;
        }
        currentBevelType = 'raised';
      } else if (type === 'inset') {
        // å†…å‡¹æ•ˆæœï¼šå³ä¸‹æµ…è‰²ï¼Œå·¦ä¸Šæ·±è‰²
        const bevelShadow = 'inset 2px 2px 4px rgba(0, 0, 0, 0.3), inset -1px -1px 2px rgba(255, 255, 255, 0.3)';
        if (!parsedStyles['box-shadow']) {
          parsedStyles['box-shadow'] = { type: 'shadow', value: bevelShadow, original: bevelShadow };
        } else {
          let existingShadow = removeBevel(parsedStyles['box-shadow'].original || parsedStyles['box-shadow'].value);
          parsedStyles['box-shadow'].original = existingShadow ? `${existingShadow}, ${bevelShadow}` : bevelShadow;
          parsedStyles['box-shadow'].value = parsedStyles['box-shadow'].original;
        }
        currentBevelType = 'inset';
      }
      updatePreview();
      autoSaveCurrentState(); // è‡ªåŠ¨ä¿å­˜
    }

    // === æ–°å¢ä¸“ä¸šåŠŸèƒ½ ===
    
    // æ¸å˜ç›¸å…³
    let gradientSettings = { type: 'none', color1: '#667eea', color2: '#764ba2', angle: 45 };

    function updateGradientType(type) {
      gradientSettings.type = type;
      const controls = document.getElementById('gradientControls');
      const angleControl = document.getElementById('linearAngle');
      
      if (type === 'none') {
        controls.style.display = 'none';
        if (parsedStyles['background-image']) {
          delete parsedStyles['background-image'];
        }
      } else {
        controls.style.display = 'block';
        angleControl.style.display = type === 'linear' ? 'block' : 'none';
        updateGradient();
      }
      updatePreview();
    }

    function updateGradient() {
      const color1Input = document.getElementById('gradientColor1');
      const color2Input = document.getElementById('gradientColor2');
      
      if (!color1Input || !color2Input) return;
      
      gradientSettings.color1 = color1Input.value;
      gradientSettings.color2 = color2Input.value;
      
      let gradient;
      if (gradientSettings.type === 'linear') {
        gradient = `linear-gradient(${gradientSettings.angle}deg, ${gradientSettings.color1}, ${gradientSettings.color2})`;
      } else if (gradientSettings.type === 'radial') {
        gradient = `radial-gradient(circle, ${gradientSettings.color1}, ${gradientSettings.color2})`;
      }
      
      if (gradient) {
        parsedStyles['background-image'] = { type: 'gradient', value: gradient, original: gradient };
      }
      updatePreview();
    }

    function updateGradientAngle(angle) {
      document.getElementById('gradient-angle-val').textContent = angle + 'deg';
      gradientSettings.angle = parseInt(angle);
      updateGradient();
    }

    // é«˜çº§æ»¤é•œ
    let filterSettings = { contrast: 100, saturate: 100, brightness: 100, hue: 0 };

    function updateContrast(value) {
      document.getElementById('contrast-val').textContent = value + '%';
      filterSettings.contrast = parseInt(value);
      applyFilters();
    }

    function updateSaturate(value) {
      document.getElementById('saturate-val').textContent = value + '%';
      filterSettings.saturate = parseInt(value);
      applyFilters();
    }

    function updateBrightness(value) {
      document.getElementById('brightness-val').textContent = value + '%';
      filterSettings.brightness = parseInt(value);
      applyFilters();
    }

    function updateHue(value) {
      document.getElementById('hue-val').textContent = value + 'deg';
      filterSettings.hue = parseInt(value);
      applyFilters();
    }

    function applyFilters() {
      const filters = [];
      if (filterSettings.contrast !== 100) filters.push(`contrast(${filterSettings.contrast}%)`);
      if (filterSettings.saturate !== 100) filters.push(`saturate(${filterSettings.saturate}%)`);
      if (filterSettings.brightness !== 100) filters.push(`brightness(${filterSettings.brightness}%)`);
      if (filterSettings.hue !== 0) filters.push(`hue-rotate(${filterSettings.hue}deg)`);
      
      if (filters.length > 0) {
        const filterStr = filters.join(' ');
        if (!parsedStyles['filter']) {
          parsedStyles['filter'] = { type: 'filter', value: filterStr, original: filterStr };
        } else {
          parsedStyles['filter'].value = filterStr;
          parsedStyles['filter'].original = filterStr;
        }
      } else if (parsedStyles['filter'] && !parsedStyles['filter'].original.includes('blur')) {
        delete parsedStyles['filter'];
      }
      updatePreview();
    }

    // æ–‡å­—é¢œè‰²
    function updateTextColor(color) {
      if (!parsedStyles['color']) {
        parsedStyles['color'] = { type: 'color', value: color, original: color };
      } else {
        parsedStyles['color'].value = color;
        parsedStyles['color'].original = color;
      }
      updatePreview();
    }

    // æ¢è¡Œæ–¹å¼
    function updateWordBreak(value) {
      if (value === 'normal') {
        delete parsedStyles['word-break'];
      } else {
        parsedStyles['word-break'] = { type: 'text', value: value, original: value };
      }
      updatePreview();
    }

    // æ–‡å­—é˜´å½±æ•ˆæœå­˜å‚¨
    let textShadowSettings = { size: 0, color: '#000000' };

    // æ–‡å­—é˜´å½±
    function updateTextShadow(size) {
      const valElement = document.getElementById('text-shadow-val');
      const colorElement = document.getElementById('textShadowColor');
      
      // å¦‚æœä¼ å…¥äº†sizeå‚æ•°ï¼ˆæ»‘å—è°ƒç”¨ï¼‰ï¼Œæ›´æ–°size
      if (size !== undefined && size !== null && size !== '') {
        textShadowSettings.size = parseInt(size);
        if (valElement) valElement.textContent = size + 'px';
      }
      
      // æ›´æ–°é¢œè‰²ï¼ˆæ€»æ˜¯ä»é€‰æ‹©å™¨è¯»å–ï¼‰
      if (colorElement) {
        textShadowSettings.color = colorElement.value;
      }
      
      // ä½¿ç”¨ä¿å­˜çš„sizeï¼Œé˜²æ­¢é¢œè‰²æ›´æ–°æ—¶sizeä¸¢å¤±
      const actualSize = textShadowSettings.size;
      
      // æ›´æ–°æ˜¾ç¤ºå€¼
      if (valElement && !size) {
        valElement.textContent = actualSize + 'px';
      }
      
      if (actualSize > 0) {
        const shadow = `${actualSize}px ${actualSize}px ${actualSize * 2}px ${textShadowSettings.color}`;
        parsedStyles['text-shadow'] = { type: 'text', value: shadow, original: shadow };
      } else {
        delete parsedStyles['text-shadow'];
      }
      updatePreview();
    }

    // æ··åˆæ¨¡å¼
    function updateBlendMode(mode) {
      if (mode === 'normal') {
        delete parsedStyles['mix-blend-mode'];
      } else {
        parsedStyles['mix-blend-mode'] = { type: 'blend', value: mode, original: mode };
      }
      updatePreview();
    }

    // åŠ¨ç”»æ•ˆæœ
    function applyAnimation(type) {
      const animations = {
        pulse: '@keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }',
        bounce: '@keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }',
        shake: '@keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }',
        glow: '@keyframes glow { 0%, 100% { box-shadow: 0 0 5px rgba(255,255,255,0.5); } 50% { box-shadow: 0 0 20px rgba(255,255,255,0.8); } }'
      };
      
      extraCSS.animations = animations[type];
      parsedStyles['animation'] = { 
        type: 'animation', 
        value: `${type} 2s ease-in-out infinite`, 
        original: `${type} 2s ease-in-out infinite` 
      };
      updatePreview();
    }

    function removeAnimation() {
      delete parsedStyles['animation'];
      extraCSS.animations = '';
      updatePreview();
    }

    // é¢„è®¾æ¨¡æ¿
    function loadPreset(preset) {
      const presets = {
        glassmorphism: {
          'background-color': { type: 'color', value: 'rgba(255, 255, 255, 0.1)', original: 'rgba(255, 255, 255, 0.1)' },
          'backdrop-filter': { type: 'text', value: 'blur(10px)', original: 'blur(10px)' },
          'border': { type: 'text', value: '1px solid rgba(255, 255, 255, 0.2)', original: '1px solid rgba(255, 255, 255, 0.2)' },
          'box-shadow': { type: 'text', value: '0 8px 32px 0 rgba(0, 0, 0, 0.1)', original: '0 8px 32px 0 rgba(0, 0, 0, 0.1)' }
        },
        neumorphism: {
          'background': { type: 'color', value: '#e0e5ec', original: '#e0e5ec' },
          'box-shadow': { type: 'text', value: '9px 9px 16px #a3b1c6, -9px -9px 16px #ffffff', original: '9px 9px 16px #a3b1c6, -9px -9px 16px #ffffff' },
          'border-radius': { type: 'size', value: 20, original: '20px' }
        },
        neon: {
          'background-color': { type: 'color', value: '#000000', original: '#000000' },
          'color': { type: 'color', value: '#00ff00', original: '#00ff00' },
          'box-shadow': { type: 'text', value: '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00', original: '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00' },
          'text-shadow': { type: 'text', value: '0 0 10px #00ff00', original: '0 0 10px #00ff00' }
        },
        minimal: {
          'background': { type: 'color', value: '#ffffff', original: '#ffffff' },
          'color': { type: 'color', value: '#000000', original: '#000000' },
          'border': { type: 'text', value: '1px solid #e5e5e5', original: '1px solid #e5e5e5' },
          'border-radius': { type: 'size', value: 12, original: '12px' },
          'padding': { type: 'text', value: '12px', original: '12px' }
        }
      };
      
      if (presets[preset]) {
        // åº”ç”¨é¢„è®¾æ ·å¼ï¼ˆä¸æ¸…ç©ºç°æœ‰æ ·å¼ï¼Œè€Œæ˜¯è¦†ç›–ï¼‰
        Object.assign(parsedStyles, presets[preset]);
        // ç›´æ¥æ›´æ–°é¢„è§ˆï¼Œä¸é‡æ–°ç”Ÿæˆæ§ä»¶ï¼ˆå› ä¸ºé¢„è®¾æ•°æ®å¯èƒ½æ²¡æœ‰editableå­—æ®µï¼‰
        updatePreview();
        alert(`å·²åº”ç”¨"${preset}"é¢„è®¾æ¨¡æ¿ï¼\næç¤ºï¼šå¦‚éœ€ç¼–è¾‘ï¼Œè¯·å…ˆè§£æCSSåå†åº”ç”¨é¢„è®¾ã€‚`);
      }
    }

    function saveCurrentAsPreset() {
      const presetName = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼š');
      if (presetName) {
        localStorage.setItem(`bubble_preset_${presetName}`, JSON.stringify(parsedStyles));
        alert('é¢„è®¾å·²ä¿å­˜åˆ°æœ¬åœ°ï¼');
      }
    }

    function exportPreset() {
      const data = {
        styles: parsedStyles,
        extraCSS: extraCSS,
        timestamp: Date.now()
      };
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `bubble-config-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      alert('é…ç½®å·²å¯¼å‡ºä¸ºJSONæ–‡ä»¶ï¼');
    }

    // å›¾åºŠURLåº”ç”¨åˆ°beforeä¼ªå…ƒç´ 
    function applyImageHostBefore() {
      const url = document.getElementById('imageHostUrl').value.trim();
      if (!url) {
        alert('è¯·å…ˆç²˜è´´å›¾åºŠé“¾æ¥');
        return;
      }
      
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„URLï¼ˆéœ€è¦http://æˆ–https://ï¼‰');
        return;
      }
      
      const pseudoKey = 'beforePseudo';
      const type = 'before';
      
      if (!extraCSS[pseudoKey]) {
        // åˆ›å»ºæ–°çš„ä¼ªå…ƒç´ 
        const className = '.sent';
        extraCSS[pseudoKey] = `${className} .message-bubble::${type} {
  content: "" !important;
  position: absolute !important;
  top: -15px !important;
  left: -15px !important;
  width: 40px !important;
  height: 40px !important;
  background-image: url(${url}) !important;
  background-size: cover !important;
  background-position: center !important;
  background-repeat: no-repeat !important;
  pointer-events: none !important;
  z-index: 10 !important;
}`;
      } else {
        // æ›´æ–°ç°æœ‰ä¼ªå…ƒç´ çš„å›¾ç‰‡
        let css = extraCSS[pseudoKey];
        if (/background-image:\s*url\([^)]+\)/i.test(css)) {
          css = css.replace(/background-image:\s*url\([^)]+\)/gi, `background-image: url(${url})`);
        } else {
          const insertPos = css.lastIndexOf('}');
          css = css.substring(0, insertPos) + `  background-image: url(${url}) !important;\n}`;
        }
        extraCSS[pseudoKey] = css;
      }
      
      pseudoProps.before = { size: 40, top: -15, left: -15 };
      generatePseudoControls();
      updatePreview();
      alert('å›¾åºŠé“¾æ¥å·²åº”ç”¨åˆ°ç”¨æˆ·è´´çº¸ï¼');
    }

    // å›¾åºŠURLåº”ç”¨åˆ°afterä¼ªå…ƒç´ 
    function applyImageHostAfter() {
      const url = document.getElementById('imageHostUrl').value.trim();
      if (!url) {
        alert('è¯·å…ˆç²˜è´´å›¾åºŠé“¾æ¥');
        return;
      }
      
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„URLï¼ˆéœ€è¦http://æˆ–https://ï¼‰');
        return;
      }
      
      const pseudoKey = 'afterPseudo';
      const type = 'after';
      
      if (!extraCSS[pseudoKey]) {
        // åˆ›å»ºæ–°çš„ä¼ªå…ƒç´ 
        const className = '.received';
        extraCSS[pseudoKey] = `${className} .message-bubble::${type} {
  content: "" !important;
  position: absolute !important;
  top: -15px !important;
  right: -15px !important;
  width: 40px !important;
  height: 40px !important;
  background-image: url(${url}) !important;
  background-size: cover !important;
  background-position: center !important;
  background-repeat: no-repeat !important;
  pointer-events: none !important;
  z-index: 10 !important;
}`;
      } else {
        // æ›´æ–°ç°æœ‰ä¼ªå…ƒç´ çš„å›¾ç‰‡
        let css = extraCSS[pseudoKey];
        if (/background-image:\s*url\([^)]+\)/i.test(css)) {
          css = css.replace(/background-image:\s*url\([^)]+\)/gi, `background-image: url(${url})`);
        } else {
          const insertPos = css.lastIndexOf('}');
          css = css.substring(0, insertPos) + `  background-image: url(${url}) !important;\n}`;
        }
        extraCSS[pseudoKey] = css;
      }
      
      pseudoProps.after = { size: 40, top: -15, right: -15 };
      generatePseudoControls();
      updatePreview();
      alert('å›¾åºŠé“¾æ¥å·²åº”ç”¨åˆ°AIè´´çº¸ï¼');
    }

    // HTMLç»“æ„æ¨¡å¼
    let htmlStructureMode = 'full'; // 'full', 'simple', 'bubble'

    function updateHtmlStructureMode(mode) {
      htmlStructureMode = mode;
      // å¦‚æœå·²æœ‰ä¼ªå…ƒç´ ï¼Œé‡æ–°ç”Ÿæˆ
      if (extraCSS.beforePseudo || extraCSS.afterPseudo) {
        const confirmed = confirm('åˆ‡æ¢HTMLç»“æ„æ¨¡å¼ä¼šé‡æ–°ç”Ÿæˆä¼ªå…ƒç´ CSSï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ');
        if (confirmed) {
          if (extraCSS.beforePseudo) {
            delete extraCSS.beforePseudo;
            createPseudoElement('before');
          }
          if (extraCSS.afterPseudo) {
            delete extraCSS.afterPseudo;
            createPseudoElement('after');
          }
        }
      }
    }

    // æ ¹æ®HTMLç»“æ„æ¨¡å¼ç”Ÿæˆé€‰æ‹©å™¨
    function getPseudoSelector(type) {
      const mode = htmlStructureMode;
      
      if (mode === 'full') {
        // å®Œæ•´ç»“æ„ï¼š.message-container.sent .message-bubble::before
        return type === 'before' 
          ? '.message-container.sent .message-bubble'
          : '.message-container.received .message-bubble';
      } else if (mode === 'simple') {
        // ç®€åŒ–ç»“æ„ï¼š.sent::before
        return type === 'before' ? '.sent' : '.received';
      } else if (mode === 'bubble') {
        // ä»…æ°”æ³¡ï¼š.message-bubble.sent::before
        return type === 'before' ? '.message-bubble.sent' : '.message-bubble.received';
      }
    }

    // å¿«é€Ÿåˆ›å»ºä¼ªå…ƒç´ 
    function createPseudoElement(type) {
      const pseudoKey = type === 'before' ? 'beforePseudo' : 'afterPseudo';
      
      if (extraCSS[pseudoKey]) {
        alert(`::${type} ä¼ªå…ƒç´ å·²å­˜åœ¨ï¼`);
        return;
      }

      // åˆ›å»ºåŸºç¡€ä¼ªå…ƒç´ CSSï¼ˆè´´çº¸æ¨¡å¼ï¼Œé»˜è®¤åœ¨å·¦ä¸Šè§’/å³ä¸Šè§’ï¼‰
      const selector = getPseudoSelector(type);
      const defaultCSS = `${selector}::${type} {
  content: "" !important;
  position: absolute !important;
  top: -10% !important;
  ${type === 'before' ? 'left' : 'right'}: -10% !important;
  width: 25% !important;
  height: 25% !important;
  max-width: 50px !important;
  max-height: 50px !important;
  pointer-events: none !important;
  z-index: 10 !important;
}`;

      extraCSS[pseudoKey] = defaultCSS;
      
      // åŒæ­¥æ›´æ–°pseudoPropsçš„åˆå§‹å€¼
      if (type === 'before') {
        pseudoProps.before = { size: 40, top: -15, left: -15 };
      } else {
        pseudoProps.after = { size: 40, top: -15, right: -15 };
      }
      
      generatePseudoControls();
      updatePreview();
      
      const typeText = type === 'before' ? 'ç”¨æˆ·æ°”æ³¡' : 'AIæ°”æ³¡';
      alert(`${typeText}çš„è´´çº¸ä½ç½®å·²åˆ›å»ºï¼\né»˜è®¤åœ¨æ°”æ³¡å·¦ä¸Šè§’ï¼Œç°åœ¨ç‚¹å‡»ã€Œé€‰æ‹©è´´çº¸å›¾ç‰‡æ–‡ä»¶ã€ä¸Šä¼ å›¾ç‰‡\nç„¶åç”¨æ»‘å—è°ƒæ•´å¤§å°å’Œä½ç½®`);
    }

    // åˆ é™¤ä¼ªå…ƒç´ 
    function deletePseudoElement(type) {
      if (!confirm(`ç¡®å®šè¦åˆ é™¤${type === 'before' ? 'ç”¨æˆ·æ°”æ³¡' : 'AIæ°”æ³¡'}çš„è´´çº¸å—ï¼Ÿ`)) {
        return;
      }
      
      if (type === 'before') {
        delete extraCSS.beforePseudo;
        pseudoProps.before = { size: 40, top: -15, left: -15 };
      } else {
        delete extraCSS.afterPseudo;
        pseudoProps.after = { size: 40, top: -15, right: -15 };
      }
      
      generatePseudoControls();
      updatePreview();
      alert('è´´çº¸å·²åˆ é™¤ï¼');
    }

    // æ›´æ–°è´´çº¸æŒ‰é’®æ˜¾ç¤º
    function updateStickerButtons() {
      const container = document.getElementById('stickerButtons');
      if (!container) return;
      
      if (currentBubbleType === 'user') {
        container.innerHTML = `
          <button onclick="createPseudoElement('before')" style="width:100%; padding:10px; background:#000; color:#fff; border:none; border-radius:6px; font-size:12px;">
            ${extraCSS.beforePseudo ? 'å·²åˆ›å»ºç”¨æˆ·è´´çº¸' : '+ åˆ›å»ºç”¨æˆ·è´´çº¸'}
          </button>
        `;
      } else {
        container.innerHTML = `
          <button onclick="createPseudoElement('after')" style="width:100%; padding:10px; background:#000; color:#fff; border:none; border-radius:6px; font-size:12px;">
            ${extraCSS.afterPseudo ? 'å·²åˆ›å»ºAIè´´çº¸' : '+ åˆ›å»ºAIè´´çº¸'}
          </button>
        `;
      }
    }

    // ç”Ÿæˆä¼ªå…ƒç´ æ§ä»¶
    function generatePseudoControls() {
      const container = document.getElementById('pseudoControls');
      container.innerHTML = '';

      // æ ¹æ®å½“å‰æ°”æ³¡ç±»å‹åªæ˜¾ç¤ºå¯¹åº”çš„ä¼ªå…ƒç´ 
      // ç”¨æˆ·tabåªæ˜¾ç¤ºç”¨æˆ·è´´çº¸ï¼ˆ::beforeï¼‰ï¼ŒAI tabåªæ˜¾ç¤ºAIè´´çº¸ï¼ˆ::afterï¼‰
      const showBefore = currentBubbleType === 'user' && extraCSS.beforePseudo;
      const showAfter = currentBubbleType === 'ai' && extraCSS.afterPseudo;

      if (!showBefore && !showAfter) {
        container.innerHTML = '<p style="color:#999;text-align:center;padding:20px;">æš‚æ— è´´çº¸</p>';
        return;
      }
      
      // åŒæ—¶æ›´æ–°è´´çº¸æŒ‰é’®
      updateStickerButtons();

      // ::before (ç”¨æˆ·è´´çº¸ï¼Œåªåœ¨ç”¨æˆ·tabæ˜¾ç¤º)
      if (showBefore) {
        // ä»CSSä¸­æå–å½“å‰å€¼ï¼ˆå–widthä½œä¸ºsizeï¼‰
        const widthMatch = extraCSS.beforePseudo.match(/width:\s*(\d+)px/i);
        const topMatch = extraCSS.beforePseudo.match(/top:\s*(-?\d+)px/i);
        const leftMatch = extraCSS.beforePseudo.match(/left:\s*(-?\d+)px/i);
        
        if (widthMatch) pseudoProps.before.size = parseInt(widthMatch[1]);
        if (topMatch) pseudoProps.before.top = parseInt(topMatch[1]);
        if (leftMatch) pseudoProps.before.left = parseInt(leftMatch[1]);
        const beforeDiv = document.createElement('div');
        beforeDiv.className = 'control-group';
        beforeDiv.innerHTML = `
          <div class="property-name" style="display:flex; justify-content:space-between; align-items:center;">
            <span>ç”¨æˆ·æ°”æ³¡è´´çº¸ ::before</span>
            <button onclick="deletePseudoElement('before')" style="background:#999; color:#fff; border:none; border-radius:4px; padding:4px 8px; font-size:11px; cursor:pointer;">åˆ é™¤</button>
          </div>
          <div style="background:#f0f0f0; padding:6px 8px; border-radius:4px; margin-bottom:6px; font-size:10px; color:#666;">
            ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ï¼Œé€‰æ‹©ç”µè„‘é‡Œçš„PNG/GIFæ–‡ä»¶ï¼Œæ— éœ€å›¾åºŠ
          </div>
          <div style="margin-bottom:8px;">
            <input type="file" id="beforeImageInput" accept="image/png,image/gif,image/jpeg" style="display:none;" onchange="handlePseudoImageUpload(event, 'before')">
            <button class="btn" onclick="document.getElementById('beforeImageInput').click()" style="width:100%; padding:8px; font-size:12px; background:#000; color:#fff;">é€‰æ‹©è´´çº¸å›¾ç‰‡æ–‡ä»¶</button>
          </div>
          
          <div style="margin-bottom:10px;">
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>è´´çº¸å¤§å°</span>
              <span id="before-size-val" style="color:#666; font-family:monospace;">${pseudoProps.before.size}px</span>
            </div>
            <input type="range" min="10" max="100" value="${pseudoProps.before.size}" 
              oninput="pseudoProps.before.size = parseInt(this.value); document.getElementById('before-size-val').textContent = this.value + 'px'; updatePseudoCSS('before');" 
              style="width:100%;">
          </div>
          
          <div style="margin-bottom:10px;">
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>ä¸Šä¸‹ä½ç½®ï¼ˆè´Ÿæ•°å‘ä¸Šï¼‰</span>
              <span id="before-top-val" style="color:#666; font-family:monospace;">${pseudoProps.before.top}px</span>
            </div>
            <input type="range" min="-100" max="100" value="${pseudoProps.before.top}" 
              oninput="pseudoProps.before.top = parseInt(this.value); document.getElementById('before-top-val').textContent = this.value + 'px'; updatePseudoCSS('before');" 
              style="width:100%;">
          </div>
          
          <div style="margin-bottom:10px;">
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>å·¦å³ä½ç½®ï¼ˆè´Ÿæ•°å‘å·¦ï¼‰</span>
              <span id="before-left-val" style="color:#666; font-family:monospace;">${pseudoProps.before.left}px</span>
            </div>
            <input type="range" min="-100" max="100" value="${pseudoProps.before.left}" 
              oninput="pseudoProps.before.left = parseInt(this.value); document.getElementById('before-left-val').textContent = this.value + 'px'; updatePseudoCSS('before');" 
              style="width:100%;">
          </div>
          
          <textarea id="beforeTextarea" style="width:100%; height:80px; font-family:'SF Mono', Monaco, monospace; font-size:10px; padding:8px; border:1px solid #e5e5e5; border-radius:6px; background:#fafafa; resize:vertical;"
            onchange="extraCSS.beforePseudo = this.value; updatePreview();">${extraCSS.beforePseudo}</textarea>
          <div style="font-size:10px; color:#999; margin-top:4px;">é«˜çº§ï¼šå¯æ‰‹åŠ¨ä¿®æ”¹ä¸Šæ–¹CSSè°ƒæ•´ä½ç½®å’Œå¤§å°</div>
        `;
        container.appendChild(beforeDiv);
      }

      // ::after (AIè´´çº¸ï¼Œåªåœ¨AI tabæ˜¾ç¤º)
      if (showAfter) {
        // ä»CSSä¸­æå–å½“å‰å€¼ï¼ˆå–widthä½œä¸ºsizeï¼‰
        const widthMatch = extraCSS.afterPseudo.match(/width:\s*(\d+)px/i);
        const topMatch = extraCSS.afterPseudo.match(/top:\s*(-?\d+)px/i);
        const rightMatch = extraCSS.afterPseudo.match(/right:\s*(-?\d+)px/i);
        
        if (widthMatch) pseudoProps.after.size = parseInt(widthMatch[1]);
        if (topMatch) pseudoProps.after.top = parseInt(topMatch[1]);
        if (rightMatch) pseudoProps.after.right = parseInt(rightMatch[1]);
        
        const afterDiv = document.createElement('div');
        afterDiv.className = 'control-group';
        afterDiv.innerHTML = `
          <div class="property-name" style="display:flex; justify-content:space-between; align-items:center;">
            <span>AIæ°”æ³¡è´´çº¸ ::after</span>
            <button onclick="deletePseudoElement('after')" style="background:#999; color:#fff; border:none; border-radius:4px; padding:4px 8px; font-size:11px; cursor:pointer;">åˆ é™¤</button>
          </div>
          <div style="background:#f0f0f0; padding:6px 8px; border-radius:4px; margin-bottom:6px; font-size:10px; color:#666;">
            ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ï¼Œé€‰æ‹©ç”µè„‘é‡Œçš„PNG/GIFæ–‡ä»¶ï¼Œæ— éœ€å›¾åºŠ
          </div>
          <div style="margin-bottom:8px;">
            <input type="file" id="afterImageInput" accept="image/png,image/gif,image/jpeg" style="display:none;" onchange="handlePseudoImageUpload(event, 'after')">
            <button class="btn" onclick="document.getElementById('afterImageInput').click()" style="width:100%; padding:8px; font-size:12px; background:#000; color:#fff;">é€‰æ‹©è´´çº¸å›¾ç‰‡æ–‡ä»¶</button>
          </div>
          
          <div style="margin-bottom:10px;">
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>è´´çº¸å¤§å°</span>
              <span id="after-size-val" style="color:#666; font-family:monospace;">${pseudoProps.after.size}px</span>
            </div>
            <input type="range" min="10" max="100" value="${pseudoProps.after.size}" 
              oninput="pseudoProps.after.size = parseInt(this.value); document.getElementById('after-size-val').textContent = this.value + 'px'; updatePseudoCSS('after');" 
              style="width:100%;">
          </div>
          
          <div style="margin-bottom:10px;">
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>ä¸Šä¸‹ä½ç½®ï¼ˆè´Ÿæ•°å‘ä¸Šï¼‰</span>
              <span id="after-top-val" style="color:#666; font-family:monospace;">${pseudoProps.after.top}px</span>
            </div>
            <input type="range" min="-100" max="100" value="${pseudoProps.after.top}" 
              oninput="pseudoProps.after.top = parseInt(this.value); document.getElementById('after-top-val').textContent = this.value + 'px'; updatePseudoCSS('after');" 
              style="width:100%;">
          </div>
          
          <div style="margin-bottom:10px;">
            <div style="font-size:11px; margin-bottom:4px; display:flex; justify-content:space-between;">
              <span>å·¦å³ä½ç½®ï¼ˆè´Ÿæ•°å‘å³ï¼‰</span>
              <span id="after-right-val" style="color:#666; font-family:monospace;">${pseudoProps.after.right}px</span>
            </div>
            <input type="range" min="-100" max="100" value="${pseudoProps.after.right}" 
              oninput="pseudoProps.after.right = parseInt(this.value); document.getElementById('after-right-val').textContent = this.value + 'px'; updatePseudoCSS('after');" 
              style="width:100%;">
          </div>
          
          <textarea id="afterTextarea" style="width:100%; height:80px; font-family:'SF Mono', Monaco, monospace; font-size:10px; padding:8px; border:1px solid #e5e5e5; border-radius:6px; background:#fafafa; resize:vertical;"
            onchange="extraCSS.afterPseudo = this.value; updatePreview();">${extraCSS.afterPseudo}</textarea>
          <div style="font-size:10px; color:#999; margin-top:4px;">é«˜çº§ï¼šå¯æ‰‹åŠ¨ä¿®æ”¹ä¸Šæ–¹CSSè°ƒæ•´ä½ç½®å’Œå¤§å°</div>
        `;
        container.appendChild(afterDiv);
      }
    }

    // ==================== æ°”æ³¡åº•å›¾åŠŸèƒ½ï¼ˆä¹å®«æ ¼æ‹‰ä¼¸ï¼‰ ====================
    
    let bubbleBaseData = {
      url: '',
      mode: 'fixed-shape',       // 'nine-slice' æˆ– 'fixed-shape'
      sliceTop: 30,
      sliceRight: 30,
      sliceBottom: 30,
      sliceLeft: 30,
      padding: 15,
      uniformPadding: true,      // æ˜¯å¦ç»Ÿä¸€è¾¹æ¡†å®½åº¦
      paddingTop: 15,            // ç‹¬ç«‹çš„ä¸Šè¾¹æ¡†å®½åº¦
      paddingRight: 15,          // ç‹¬ç«‹çš„å³è¾¹æ¡†å®½åº¦
      paddingBottom: 15,         // ç‹¬ç«‹çš„ä¸‹è¾¹æ¡†å®½åº¦
      paddingLeft: 15,           // ç‹¬ç«‹çš„å·¦è¾¹æ¡†å®½åº¦
      widthMode: 'percent',      // 'percent' æˆ– 'pixel'
      maxWidthPercent: 65,       // ç™¾åˆ†æ¯”å€¼
      maxWidthPixel: 300,        // åƒç´ å€¼
      repeat: 'stretch',
      removeBackground: true     // æ˜¯å¦æ¶ˆé™¤åº•å—ï¼ˆå¼ºåˆ¶é€æ˜èƒŒæ™¯ï¼‰
    };
    
    // åˆ‡æ¢å®½åº¦æ¨¡å¼
    function setWidthMode(mode) {
      bubbleBaseData.widthMode = mode;
      
      const percentBtn = document.getElementById('widthPercentBtn');
      const pixelBtn = document.getElementById('widthPixelBtn');
      const percentControl = document.getElementById('widthPercentControl');
      const pixelControl = document.getElementById('widthPixelControl');
      
      if (mode === 'percent') {
        percentBtn.style.background = '#000';
        percentBtn.style.color = '#fff';
        pixelBtn.style.background = '#f0f0f0';
        pixelBtn.style.color = '#666';
        percentControl.style.display = 'block';
        pixelControl.style.display = 'none';
        
        // æ›´æ–°æ ·å¼
        if (parsedStyles['border-image-source']) {
          parsedStyles['max-width'] = {
            type: 'maxwidth',
            maxWidthValue: bubbleBaseData.maxWidthPercent,
            original: `${bubbleBaseData.maxWidthPercent}%`
          };
          triggerPreviewUpdate();
        }
      } else {
        percentBtn.style.background = '#f0f0f0';
        percentBtn.style.color = '#666';
        pixelBtn.style.background = '#000';
        pixelBtn.style.color = '#fff';
        percentControl.style.display = 'none';
        pixelControl.style.display = 'block';
        
        // æ›´æ–°æ ·å¼
        if (parsedStyles['border-image-source']) {
          parsedStyles['max-width'] = {
            type: 'text',
            value: `${bubbleBaseData.maxWidthPixel}px`,
            original: `${bubbleBaseData.maxWidthPixel}px`
          };
          triggerPreviewUpdate();
        }
      }
    }
    
    // æ›´æ–°ç™¾åˆ†æ¯”å®½åº¦
    function updateBubbleMaxWidthPercent(value) {
      bubbleBaseData.maxWidthPercent = parseInt(value);
      document.getElementById('bubble-maxwidth-percent-val').textContent = value + '%';
      
      if (parsedStyles['border-image-source']) {
        parsedStyles['max-width'] = {
          type: 'maxwidth',
          maxWidthValue: bubbleBaseData.maxWidthPercent,
          original: `${bubbleBaseData.maxWidthPercent}%`
        };
        triggerPreviewUpdate();
      }
    }
    
    // æ›´æ–°åƒç´ å®½åº¦
    function updateBubbleMaxWidthPixel(value) {
      bubbleBaseData.maxWidthPixel = parseInt(value);
      document.getElementById('bubble-maxwidth-pixel-val').textContent = value + 'px';
      
      if (parsedStyles['border-image-source']) {
        parsedStyles['max-width'] = {
          type: 'text',
          value: `${bubbleBaseData.maxWidthPixel}px`,
          original: `${bubbleBaseData.maxWidthPixel}px`
        };
        triggerPreviewUpdate();
      }
    }
    
    // å¤„ç†åº•å›¾ä¸Šä¼ 
    function handleBubbleBaseUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        bubbleBaseData.url = e.target.result;
        
        // æ˜¾ç¤ºé¢„è§ˆ
        document.getElementById('bubbleBaseThumb').src = e.target.result;
        document.getElementById('bubbleBasePreview').style.display = 'block';
        
        // åˆå§‹åŒ–åˆ‡ç‰‡çº¿ä½ç½®
        updateSliceVisualization();
      };
      reader.readAsDataURL(file);
    }
    
    // åˆ‡æ¢åˆ‡ç‰‡çº¿æ˜¾ç¤º
    function toggleSliceVisibility() {
      const svg = document.getElementById('sliceGrid');
      const checkbox = document.getElementById('toggleSliceLines');
      if (svg) {
        svg.style.display = checkbox.checked ? 'block' : 'none';
      }
    }
    
    // æ›´æ–°åˆ‡ç‰‡çº¿å¯è§†åŒ–
    function updateSliceVisualization() {
      const lineTop = document.getElementById('sliceLineTop');
      const lineRight = document.getElementById('sliceLineRight');
      const lineBottom = document.getElementById('sliceLineBottom');
      const lineLeft = document.getElementById('sliceLineLeft');
      
      if (lineTop) {
        lineTop.setAttribute('y1', bubbleBaseData.sliceTop);
        lineTop.setAttribute('y2', bubbleBaseData.sliceTop);
      }
      if (lineRight) {
        lineRight.setAttribute('transform', `translate(-${bubbleBaseData.sliceRight}, 0)`);
      }
      if (lineBottom) {
        lineBottom.setAttribute('transform', `translate(0, -${bubbleBaseData.sliceBottom})`);
      }
      if (lineLeft) {
        lineLeft.setAttribute('x1', bubbleBaseData.sliceLeft);
        lineLeft.setAttribute('x2', bubbleBaseData.sliceLeft);
      }
    }
    
    // æ›´æ–°åˆ‡ç‰‡ä½ç½®ï¼ˆå››ä¸ªæ–¹å‘ç‹¬ç«‹ï¼‰
    function updateBubbleBaseSliceDetail(direction, value) {
      const val = parseInt(value);
      
      if (direction === 'top') {
        bubbleBaseData.sliceTop = val;
        document.getElementById('slice-top-val').textContent = value + 'px';
        // æ›´æ–°å¯è§†åŒ–åˆ‡ç‰‡çº¿
        const lineTop = document.getElementById('sliceLineTop');
        if (lineTop) {
          lineTop.setAttribute('y1', val);
          lineTop.setAttribute('y2', val);
        }
      } else if (direction === 'right') {
        bubbleBaseData.sliceRight = val;
        document.getElementById('slice-right-val').textContent = value + 'px';
        // æ›´æ–°å¯è§†åŒ–åˆ‡ç‰‡çº¿
        const lineRight = document.getElementById('sliceLineRight');
        if (lineRight) {
          lineRight.setAttribute('transform', `translate(-${val}, 0)`);
        }
      } else if (direction === 'bottom') {
        bubbleBaseData.sliceBottom = val;
        document.getElementById('slice-bottom-val').textContent = value + 'px';
        // æ›´æ–°å¯è§†åŒ–åˆ‡ç‰‡çº¿
        const lineBottom = document.getElementById('sliceLineBottom');
        if (lineBottom) {
          lineBottom.setAttribute('transform', `translate(0, -${val})`);
        }
      } else if (direction === 'left') {
        bubbleBaseData.sliceLeft = val;
        document.getElementById('slice-left-val').textContent = value + 'px';
        // æ›´æ–°å¯è§†åŒ–åˆ‡ç‰‡çº¿
        const lineLeft = document.getElementById('sliceLineLeft');
        if (lineLeft) {
          lineLeft.setAttribute('x1', val);
          lineLeft.setAttribute('x2', val);
        }
      }
      
      // å¦‚æœå·²åº”ç”¨ï¼Œå®æ—¶æ›´æ–°
      if (parsedStyles['border-image-source']) {
        const sliceValue = `${bubbleBaseData.sliceTop} ${bubbleBaseData.sliceRight} ${bubbleBaseData.sliceBottom} ${bubbleBaseData.sliceLeft} fill`;
        parsedStyles['border-image-slice'].value = sliceValue;
        parsedStyles['border-image-slice'].original = sliceValue;
        triggerPreviewUpdate();
      }
    }
    
    // æ›´æ–°å†…è¾¹è·ï¼ˆè¾¹æ¡†æ¸²æŸ“å®½åº¦ï¼‰
    function updateBubbleBasePadding(value) {
      bubbleBaseData.padding = parseInt(value);
      document.getElementById('bubble-padding-val').textContent = value + 'px';
      
      // å¦‚æœå·²åº”ç”¨ï¼Œå®æ—¶æ›´æ–°
      if (parsedStyles['border-image-source']) {
        const val = bubbleBaseData.padding;
        // æ›´æ–°border-image-widthï¼ˆä½¿ç”¨åƒç´ å€¼ï¼‰
        parsedStyles['border-image-width'].value = `${val}px`;
        parsedStyles['border-image-width'].original = `${val}px`;
        // æ³¨æ„ï¼šæ–‡å­—paddingç”±ç‹¬ç«‹çš„æ»‘å—æ§åˆ¶ï¼Œä¸åœ¨è¿™é‡Œæ›´æ–°
        triggerPreviewUpdate();
      }
    }
    
    // åˆ‡æ¢ç»Ÿä¸€/ç‹¬ç«‹è¾¹æ¡†å®½åº¦æ¨¡å¼
    function toggleUniformPadding() {
      const checked = document.getElementById('uniformPadding').checked;
      bubbleBaseData.uniformPadding = checked;
      
      document.getElementById('uniformPaddingControl').style.display = checked ? 'block' : 'none';
      document.getElementById('separatePaddingControl').style.display = checked ? 'none' : 'block';
      
      // å¦‚æœåˆ‡æ¢åˆ°ç‹¬ç«‹æ¨¡å¼ï¼ŒåŒæ­¥å½“å‰çš„ç»Ÿä¸€å€¼
      if (!checked) {
        const val = bubbleBaseData.padding;
        bubbleBaseData.paddingTop = val;
        bubbleBaseData.paddingRight = val;
        bubbleBaseData.paddingBottom = val;
        bubbleBaseData.paddingLeft = val;
        
        document.getElementById('padding-top-val').textContent = val + 'px';
        document.getElementById('paddingTopSlider').value = val;
        document.getElementById('padding-right-val').textContent = val + 'px';
        document.getElementById('paddingRightSlider').value = val;
        document.getElementById('padding-bottom-val').textContent = val + 'px';
        document.getElementById('paddingBottomSlider').value = val;
        document.getElementById('padding-left-val').textContent = val + 'px';
        document.getElementById('paddingLeftSlider').value = val;
      }
      
      // å¦‚æœå·²åº”ç”¨ï¼Œè§¦å‘æ›´æ–°
      if (parsedStyles['border-image-source']) {
        applyBubbleBase();
      }
    }
    
    // æ›´æ–°ç‹¬ç«‹çš„è¾¹æ¡†å®½åº¦
    function updatePaddingSeparate(direction, value) {
      const val = parseInt(value);
      
      if (direction === 'top') {
        bubbleBaseData.paddingTop = val;
        document.getElementById('padding-top-val').textContent = value + 'px';
      } else if (direction === 'right') {
        bubbleBaseData.paddingRight = val;
        document.getElementById('padding-right-val').textContent = value + 'px';
      } else if (direction === 'bottom') {
        bubbleBaseData.paddingBottom = val;
        document.getElementById('padding-bottom-val').textContent = value + 'px';
      } else if (direction === 'left') {
        bubbleBaseData.paddingLeft = val;
        document.getElementById('padding-left-val').textContent = value + 'px';
      }
      
      // å¦‚æœå·²åº”ç”¨ï¼Œå®æ—¶æ›´æ–°
      if (parsedStyles['border-image-source']) {
        // ä½¿ç”¨åƒç´ å€¼
        const widthValue = `${bubbleBaseData.paddingTop}px ${bubbleBaseData.paddingRight}px ${bubbleBaseData.paddingBottom}px ${bubbleBaseData.paddingLeft}px`;
        parsedStyles['border-image-width'].value = widthValue;
        parsedStyles['border-image-width'].original = widthValue;
        // æ³¨æ„ï¼šæ–‡å­—paddingç”±ç‹¬ç«‹çš„æ»‘å—æ§åˆ¶ï¼Œä¸åœ¨è¿™é‡Œæ›´æ–°
        
        triggerPreviewUpdate();
      }
    }
    
    // æ›´æ–°å­—ä½“å¤§å°
    function updateBubbleFontSize(value) {
      const val = parseInt(value);
      document.getElementById('bubble-fontsize-val').textContent = value + 'px';
      
      // æ›´æ–°parsedStylesä¸­çš„font-size
      parsedStyles['font-size'] = {
        type: 'size',
        size: val,
        original: `${val}px`
      };
      
      triggerPreviewUpdate();
    }
    
    // æ–‡å­—å†…è¾¹è·çŠ¶æ€
    let textPadding = {
      vertical: 10,
      horizontal: 12
    };
    
    // æ›´æ–°æ–‡å­—å†…è¾¹è·
    function updateTextPadding(direction, value) {
      const val = parseInt(value);
      
      if (direction === 'v') {
        textPadding.vertical = val;
        document.getElementById('text-padding-v-val').textContent = value + 'px';
      } else if (direction === 'h') {
        textPadding.horizontal = val;
        document.getElementById('text-padding-h-val').textContent = value + 'px';
      }
      
      // æ›´æ–°paddingï¼ˆç‹¬ç«‹äºborder-image-widthçš„paddingï¼‰
      parsedStyles['padding'] = {
        type: 'text',
        value: `${textPadding.vertical}px ${textPadding.horizontal}px`,
        original: `${textPadding.vertical}px ${textPadding.horizontal}px`
      };
      
      triggerPreviewUpdate();
    }
    
    // æ›´æ–°é‡å¤æ¨¡å¼
    function updateBubbleBaseRepeat(value) {
      bubbleBaseData.repeat = value;
      
      // å¦‚æœå·²åº”ç”¨ï¼Œå®æ—¶æ›´æ–°
      if (parsedStyles['border-image-repeat']) {
        parsedStyles['border-image-repeat'].value = value;
        parsedStyles['border-image-repeat'].original = value;
        triggerPreviewUpdate();
      }
    }
    
    // åˆ‡æ¢åº•å›¾æ¨¡å¼
    function updateBubbleBaseMode(mode) {
      bubbleBaseData.mode = mode;
      
      // æ˜¾ç¤º/éšè—ä¹å®«æ ¼æ§ä»¶
      const nineSliceControls = document.getElementById('nineSliceControls');
      if (mode === 'nine-slice') {
        nineSliceControls.style.display = 'block';
      } else {
        nineSliceControls.style.display = 'none';
      }
      
      // å¦‚æœå·²åº”ç”¨åº•å›¾ï¼Œé‡æ–°åº”ç”¨ä»¥æ›´æ–°æ ·å¼
      if (parsedStyles['border-image-source'] || parsedStyles['background-image']) {
        applyBubbleBase();
      }
    }
    
    // åˆ‡æ¢æ˜¯å¦æ¶ˆé™¤åº•å—
    function toggleBackgroundRemoval() {
      const checked = document.getElementById('removeBackgroundColor').checked;
      bubbleBaseData.removeBackground = checked;
      
      // å¦‚æœå·²åº”ç”¨åº•å›¾ï¼Œç«‹å³æ›´æ–°
      if (parsedStyles['border-image-source']) {
        if (checked) {
          // å¼ºåˆ¶é€æ˜èƒŒæ™¯
          parsedStyles['background'] = {
            type: 'text',
            value: 'transparent',
            original: 'transparent'
          };
          parsedStyles['background-color'] = {
            type: 'text',
            value: 'transparent',
            original: 'transparent'
          };
        } else {
          // ç§»é™¤å¼ºåˆ¶é€æ˜ï¼ˆä¿ç•™åŸæœ‰èƒŒæ™¯ï¼‰
          delete parsedStyles['background'];
          delete parsedStyles['background-color'];
        }
        triggerPreviewUpdate();
      }
    }
    
    // å¿«æ·é¢„è®¾
    function applyPreset(type) {
      const presets = {
        'compact': {
          widthMode: 'percent',
          maxWidthPercent: 45,
          padding: 10,
          sliceTop: 25, sliceRight: 25, sliceBottom: 25, sliceLeft: 25
        },
        'normal': {
          widthMode: 'percent',
          maxWidthPercent: 65,
          padding: 15,
          sliceTop: 30, sliceRight: 30, sliceBottom: 30, sliceLeft: 30
        },
        'wide': {
          widthMode: 'percent',
          maxWidthPercent: 80,
          padding: 18,
          sliceTop: 35, sliceRight: 35, sliceBottom: 35, sliceLeft: 35
        },
        'full': {
          widthMode: 'pixel',
          maxWidthPixel: 600,
          padding: 20,
          sliceTop: 40, sliceRight: 40, sliceBottom: 40, sliceLeft: 40
        }
      };
      
      const preset = presets[type];
      if (!preset) return;
      
      // åº”ç”¨é¢„è®¾å€¼
      bubbleBaseData.widthMode = preset.widthMode;
      bubbleBaseData.maxWidthPercent = preset.maxWidthPercent || bubbleBaseData.maxWidthPercent;
      bubbleBaseData.maxWidthPixel = preset.maxWidthPixel || bubbleBaseData.maxWidthPixel;
      bubbleBaseData.padding = preset.padding;
      bubbleBaseData.sliceTop = preset.sliceTop;
      bubbleBaseData.sliceRight = preset.sliceRight;
      bubbleBaseData.sliceBottom = preset.sliceBottom;
      bubbleBaseData.sliceLeft = preset.sliceLeft;
      
      // æ›´æ–°UI
      setWidthMode(preset.widthMode);
      document.getElementById('bubble-maxwidth-percent-val').textContent = preset.maxWidthPercent + '%';
      document.getElementById('bubble-maxwidth-pixel-val').textContent = (preset.maxWidthPixel || 300) + 'px';
      document.getElementById('bubbleMaxWidthPercentSlider').value = preset.maxWidthPercent || 65;
      document.getElementById('bubbleMaxWidthPixelSlider').value = preset.maxWidthPixel || 300;
      document.getElementById('bubble-padding-val').textContent = preset.padding + 'px';
      document.getElementById('bubblePaddingSlider').value = preset.padding;
      document.getElementById('slice-top-val').textContent = preset.sliceTop + 'px';
      document.getElementById('sliceTopSlider').value = preset.sliceTop;
      document.getElementById('slice-right-val').textContent = preset.sliceRight + 'px';
      document.getElementById('sliceRightSlider').value = preset.sliceRight;
      document.getElementById('slice-bottom-val').textContent = preset.sliceBottom + 'px';
      document.getElementById('sliceBottomSlider').value = preset.sliceBottom;
      document.getElementById('slice-left-val').textContent = preset.sliceLeft + 'px';
      document.getElementById('sliceLeftSlider').value = preset.sliceLeft;
      
      // å¦‚æœå·²åº”ç”¨åº•å›¾ï¼Œå®æ—¶æ›´æ–°æ ·å¼
      if (parsedStyles['border-image-source']) {
        applyBubbleBase();
      }
    }
    
    // åº”ç”¨åº•å›¾
    function applyBubbleBase() {
      if (!bubbleBaseData.url) {
        alert('è¯·å…ˆä¸Šä¼ åº•å›¾');
        return;
      }
      
      // æ¸…é™¤æ—§æ ·å¼
      delete parsedStyles['border-image-source'];
      delete parsedStyles['border-image-slice'];
      delete parsedStyles['border-image-width'];
      delete parsedStyles['border-image-repeat'];
      delete parsedStyles['border-style'];
      delete parsedStyles['border-color'];
      delete parsedStyles['border-width'];
      delete parsedStyles['background-image'];
      delete parsedStyles['background-size'];
      delete parsedStyles['background-repeat'];
      delete parsedStyles['background-position'];
      
      if (bubbleBaseData.mode === 'fixed-shape') {
        // â­ å›ºå®šå½¢çŠ¶æ¨¡å¼ - é€‚åˆä¸è§„åˆ™åº•å›¾ï¼ˆçŒ«å’ªç­‰ï¼‰
        parsedStyles['background-image'] = {
          type: 'text',
          value: `url(${bubbleBaseData.url})`,
          original: `url(${bubbleBaseData.url})`
        };
        
        // ä¿æŒå›¾ç‰‡æ¯”ä¾‹ï¼Œå®Œæ•´æ˜¾ç¤º
        parsedStyles['background-size'] = {
          type: 'text',
          value: '100% auto',
          original: '100% auto'
        };
        
        parsedStyles['background-repeat'] = {
          type: 'text',
          value: 'no-repeat',
          original: 'no-repeat'
        };
        
        parsedStyles['background-position'] = {
          type: 'text',
          value: 'center',
          original: 'center'
        };
        
        // è®¾ç½®åˆé€‚å°ºå¯¸èŒƒå›´ï¼ˆæ›´å°æ›´åˆç†ï¼‰
        parsedStyles['min-width'] = {
          type: 'text',
          value: '160px',
          original: '160px'
        };
        
        parsedStyles['max-width'] = {
          type: 'text',
          value: '280px',
          original: '280px'
        };
        
        // é«˜åº¦è‡ªé€‚åº”å†…å®¹å’ŒèƒŒæ™¯å›¾
        parsedStyles['min-height'] = {
          type: 'text',
          value: '120px',
          original: '120px'
        };
        
        // ä½¿ç”¨paddingç¡®ä¿æ–‡å­—åŒºåŸŸå’ŒèƒŒæ™¯å›¾åŒ¹é…ï¼ˆå‡å°paddingè®©æ°”æ³¡æ›´ç´§å‡‘ï¼‰
        parsedStyles['padding'] = {
          type: 'text',
          value: '40px 30px',
          original: '40px 30px'
        };
        
        // å›ºå®šå½¢çŠ¶æ¨¡å¼ï¼šæ–‡å­—å±…ä¸­å¯¹é½
        parsedStyles['display'] = {
          type: 'text',
          value: 'flex',
          original: 'flex'
        };
        
        parsedStyles['align-items'] = {
          type: 'text',
          value: 'center',
          original: 'center'
        };
        
        parsedStyles['justify-content'] = {
          type: 'text',
          value: 'center',
          original: 'center'
        };
        
        parsedStyles['text-align'] = {
          type: 'text',
          value: 'center',
          original: 'center'
        };
        
      } else {
        // ğŸ“ ä¹å®«æ ¼æ‹‰ä¼¸æ¨¡å¼ - é€‚åˆè§„åˆ™è¾¹æ¡†
        parsedStyles['border-image-source'] = {
          type: 'text',
          value: `url(${bubbleBaseData.url})`,
          original: `url(${bubbleBaseData.url})`
        };
      
      parsedStyles['border-image-slice'] = {
        type: 'text',
        value: `${bubbleBaseData.sliceTop} ${bubbleBaseData.sliceRight} ${bubbleBaseData.sliceBottom} ${bubbleBaseData.sliceLeft} fill`,
        original: `${bubbleBaseData.sliceTop} ${bubbleBaseData.sliceRight} ${bubbleBaseData.sliceBottom} ${bubbleBaseData.sliceLeft} fill`
      };
      
      // â­ ç®€åŒ–æ–¹æ¡ˆï¼šç›´æ¥ç”¨åƒç´ å€¼çš„border-image-widthï¼Œä¸ç”¨outset
      // è¿™æ ·å¸ƒå±€æ›´ç¨³å®šï¼Œè™½ç„¶ä¼šå ç”¨ä¸€äº›ç©ºé—´ï¼Œä½†ä¸ä¼šä¹±é£
      
      // æ ¹æ®uniformPaddingå†³å®šä½¿ç”¨ç»Ÿä¸€å€¼è¿˜æ˜¯4ä¸ªç‹¬ç«‹å€¼
      const widthValue = bubbleBaseData.uniformPadding 
        ? `${bubbleBaseData.padding}px`
        : `${bubbleBaseData.paddingTop}px ${bubbleBaseData.paddingRight}px ${bubbleBaseData.paddingBottom}px ${bubbleBaseData.paddingLeft}px`;
      
      // border-image-widthç›´æ¥ç”¨åƒç´ å€¼
      parsedStyles['border-image-width'] = {
        type: 'text',
        value: widthValue,
        original: widthValue
      };
      
      // border-widthè®¾ç½®ä¸º0ï¼Œé¿å…é¢å¤–ç©ºé—´
      parsedStyles['border-width'] = {
        type: 'text',
        value: '0',
        original: '0'
      };
      
      parsedStyles['border-image-repeat'] = {
        type: 'text',
        value: bubbleBaseData.repeat,
        original: bubbleBaseData.repeat
      };
      
      // è®¾ç½®é€æ˜è¾¹æ¡†æ ·å¼ï¼ˆå¿…é¡»ï¼‰
      parsedStyles['border-style'] = {
        type: 'text',
        value: 'solid',
        original: 'solid'
      };
      
      parsedStyles['border-color'] = {
        type: 'text',
        value: 'transparent',
        original: 'transparent'
      };
      
      // å…³é”®ï¼šç¡®ä¿åº•å›¾ä¸è¢«è£å‰ªä¸”æ”¯æŒæ¢è¡Œ
      parsedStyles['box-sizing'] = {
        type: 'text',
        value: 'border-box',
        original: 'border-box'
      };
      
      parsedStyles['display'] = {
        type: 'text',
        value: 'inline-block',
        original: 'inline-block'
      };
      
        // â­ ä¹å®«æ ¼æ¨¡å¼ï¼šæ ¹æ®ç”¨æˆ·é€‰æ‹©å†³å®šæ˜¯å¦æ¶ˆé™¤åº•å—
        if (bubbleBaseData.removeBackground) {
          // å¼ºåˆ¶é€æ˜èƒŒæ™¯ï¼Œæ¶ˆé™¤åº•å—
          parsedStyles['background'] = {
            type: 'text',
            value: 'transparent',
            original: 'transparent'
          };
          parsedStyles['background-color'] = {
            type: 'text',
            value: 'transparent',
            original: 'transparent'
          };
        }
      } // ç»“æŸif (bubbleBaseData.mode === 'fixed-shape')åˆ¤æ–­
      
      // é€šç”¨æ ·å¼ï¼ˆä¸¤ç§æ¨¡å¼éƒ½éœ€è¦ï¼‰
      // ä½¿ç”¨ç”¨æˆ·è‡ªå®šä¹‰çš„æ–‡å­—paddingï¼ˆç²¾ç»†å¯¹é½ï¼‰
      parsedStyles['padding'] = {
        type: 'text',
        value: `${textPadding.vertical}px ${textPadding.horizontal}px`,
        original: `${textPadding.vertical}px ${textPadding.horizontal}px`
      };
      
      // ç¡®ä¿æ–‡å­—æ¢è¡Œ
      parsedStyles['word-wrap'] = {
        type: 'text',
        value: 'break-word',
        original: 'break-word'
      };
      
      parsedStyles['word-break'] = {
        type: 'text',
        value: 'break-word',
        original: 'break-word'
      };
      
      parsedStyles['white-space'] = {
        type: 'text',
        value: 'pre-wrap',
        original: 'pre-wrap'
      };
      
      // å…³é”®ï¼šé™åˆ¶å®½åº¦ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©çš„æ¨¡å¼ï¼‰
      if (bubbleBaseData.widthMode === 'percent') {
        parsedStyles['max-width'] = {
          type: 'maxwidth',
          maxWidthValue: bubbleBaseData.maxWidthPercent,
          original: `${bubbleBaseData.maxWidthPercent}%`
        };
      } else {
        parsedStyles['max-width'] = {
          type: 'text',
          value: `${bubbleBaseData.maxWidthPixel}px`,
          original: `${bubbleBaseData.maxWidthPixel}px`
        };
      }
      
      // ç§»é™¤border-radiusï¼ˆä¹å®«æ ¼æ‹‰ä¼¸ä¸æ”¯æŒåœ†è§’ï¼‰
      if (parsedStyles['border-radius']) {
        delete parsedStyles['border-radius'];
      }
      
      updatePreview();
      
      const modeInfo = bubbleBaseData.mode === 'fixed-shape' 
        ? 'â­ å›ºå®šå½¢çŠ¶æ¨¡å¼ - çŒ«å’ªç­‰ä¸è§„åˆ™åº•å›¾' 
        : 'ğŸ“ ä¹å®«æ ¼æ‹‰ä¼¸æ¨¡å¼ - è§„åˆ™è¾¹æ¡†';
      
      alert(`âœ… åº•å›¾å·²åº”ç”¨ï¼
      
${modeInfo}

âš ï¸ HTMLç»“æ„ï¼š
<div class="message-container sent">
  <div class="message-bubble">ç”¨æˆ·æ¶ˆæ¯</div>
</div>
<div class="message-container received">
  <div class="message-bubble">AIæ¶ˆæ¯</div>
</div>

ğŸ“ å¯è°ƒæ•´å‚æ•°ï¼š
â€¢ åº•å›¾æ¨¡å¼ â†’ åˆ‡æ¢"å›ºå®šå½¢çŠ¶"æˆ–"ä¹å®«æ ¼æ‹‰ä¼¸"
â€¢ æ–‡å­—å†…è¾¹è· â†’ å¾®è°ƒæ–‡å­—ä½ç½®å¯¹é½ï¼ˆä¸Šä¸‹/å·¦å³ç‹¬ç«‹ï¼‰
â€¢ å®½åº¦æ§åˆ¶ â†’ æ§åˆ¶æ°”æ³¡æœ€å¤§å®½åº¦

${bubbleBaseData.mode === 'fixed-shape' 
  ? `â­ å›ºå®šå½¢çŠ¶æ¨¡å¼ï¼š
â€¢ é€‚åˆçŒ«å’ªç­‰ä¸è§„åˆ™åº•å›¾
â€¢ åº•å›¾ä¸ä¼šå˜å½¢
â€¢ æ–‡å­—è‡ªåŠ¨å±…ä¸­
â€¢ å¤šè¡Œæ–‡å­—ä¼šè®©æ°”æ³¡å˜å¤§ä½†ä¿æŒå½¢çŠ¶`
  : `ğŸ“ ä¹å®«æ ¼æ‹‰ä¼¸æ¨¡å¼ï¼š
â€¢ åˆ‡ç‰‡ä½ç½®ï¼ˆ4ä¸ªç‹¬ç«‹æ»‘å—ï¼‰â†’ æ§åˆ¶å“ªé‡Œè¢«æ‹‰ä¼¸
â€¢ è¾¹æ¡†æ¸²æŸ“å®½åº¦ â†’ æ§åˆ¶åº•å›¾è¾¹æ¡†å¤§å°ï¼ˆ5-50pxï¼‰
â€¢ â­ æ¶ˆé™¤åº•å— â†’ å¼ºåˆ¶é€æ˜èƒŒæ™¯
â€¢ é€‚åˆåœ†è§’çŸ©å½¢ç­‰è§„åˆ™è¾¹æ¡†`}

ğŸ“‹ ç‚¹å‡»"å¤åˆ¶CSS"è·å–å®Œæ•´ä»£ç `);
    }
    
    // ç§»é™¤åº•å›¾
    function removeBubbleBase() {
      // æ¸…ç†border-imageç›¸å…³
      delete parsedStyles['border-image-source'];
      delete parsedStyles['border-image-slice'];
      delete parsedStyles['border-image-width'];
      delete parsedStyles['border-image-repeat'];
      delete parsedStyles['border-style'];
      delete parsedStyles['border-color'];
      delete parsedStyles['border-width'];
      // æ¸…ç†background-imageç›¸å…³
      delete parsedStyles['background-image'];
      delete parsedStyles['background-size'];
      delete parsedStyles['background-repeat'];
      delete parsedStyles['background-position'];
      delete parsedStyles['width'];
      delete parsedStyles['height'];
      delete parsedStyles['min-width'];
      delete parsedStyles['min-height'];
      delete parsedStyles['aspect-ratio'];
      // æ¸…ç†flexå¸ƒå±€ç›¸å…³
      delete parsedStyles['align-items'];
      delete parsedStyles['justify-content'];
      delete parsedStyles['text-align'];
      // æ¸…ç†å…¶ä»–æ ·å¼
      delete parsedStyles['word-wrap'];
      delete parsedStyles['word-break'];
      delete parsedStyles['white-space'];
      delete parsedStyles['max-width'];
      delete parsedStyles['box-sizing'];
      delete parsedStyles['display'];
      
      bubbleBaseData = { 
        url: '', 
        mode: 'fixed-shape',
        sliceTop: 30, 
        sliceRight: 30, 
        sliceBottom: 30, 
        sliceLeft: 30, 
        padding: 15,
        uniformPadding: true,
        paddingTop: 15,
        paddingRight: 15,
        paddingBottom: 15,
        paddingLeft: 15,
        widthMode: 'percent', 
        maxWidthPercent: 65, 
        maxWidthPixel: 300, 
        repeat: 'stretch',
        removeBackground: true
      };
      document.getElementById('bubbleBasePreview').style.display = 'none';
      
      // é‡ç½®æ»‘å—å’Œæ˜¾ç¤º
      document.getElementById('sliceTopSlider').value = 30;
      document.getElementById('slice-top-val').textContent = '30px';
      document.getElementById('sliceRightSlider').value = 30;
      document.getElementById('slice-right-val').textContent = '30px';
      document.getElementById('sliceBottomSlider').value = 30;
      document.getElementById('slice-bottom-val').textContent = '30px';
      document.getElementById('sliceLeftSlider').value = 30;
      document.getElementById('slice-left-val').textContent = '30px';
      document.getElementById('bubblePaddingSlider').value = 15;
      document.getElementById('bubble-padding-val').textContent = '15px';
      
      // é‡ç½®æ¨¡å¼é€‰æ‹©
      document.getElementById('bubbleBaseMode').value = 'fixed-shape';
      document.getElementById('nineSliceControls').style.display = 'none';
      
      // é‡ç½®ç‹¬ç«‹è¾¹æ¡†å®½åº¦æ¨¡å¼
      document.getElementById('uniformPadding').checked = true;
      document.getElementById('uniformPaddingControl').style.display = 'block';
      document.getElementById('separatePaddingControl').style.display = 'none';
      
      // é‡ç½®æ¶ˆé™¤åº•å—é€‰é¡¹
      document.getElementById('removeBackgroundColor').checked = true;
      
      updatePreview();
      alert('åº•å›¾å·²ç§»é™¤');
    }
    
    // ==================== æ‰‹æœºç«¯é¢„è§ˆåŒæ­¥ä¼˜åŒ– ====================
    
    // ç»Ÿä¸€çš„é¢„è§ˆè§¦å‘å‡½æ•°ï¼ˆå¸¦é˜²æŠ–ï¼‰
    let previewUpdateTimer = null;
    function triggerPreviewUpdate() {
      if (previewUpdateTimer) {
        clearTimeout(previewUpdateTimer);
      }
      
      // æ‰‹æœºç«¯ä½¿ç”¨æ›´çŸ­çš„é˜²æŠ–æ—¶é—´ï¼ˆ50msï¼‰ï¼Œæ¡Œé¢ç«¯30ms
      const isMobile = window.innerWidth < 768;
      const debounceTime = isMobile ? 50 : 30;
      
      previewUpdateTimer = setTimeout(() => {
        updatePreview();
      }, debounceTime);
    }
    
    // ä¼˜åŒ–ï¼šä½¿ç”¨passiveäº‹ä»¶ç›‘å¬å™¨æå‡æ»šåŠ¨æ€§èƒ½
    document.addEventListener('DOMContentLoaded', function() {
      const ranges = document.querySelectorAll('input[type="range"]');
      ranges.forEach(range => {
        // ç¡®ä¿æ‰€æœ‰æ»‘å—éƒ½è°ƒç”¨triggerPreviewUpdate
        if (!range.getAttribute('oninput')?.includes('triggerPreviewUpdate')) {
          const oldHandler = range.oninput;
          range.oninput = function() {
            if (oldHandler) oldHandler.call(this);
            triggerPreviewUpdate();
          };
        }
        
        // æ·»åŠ touchendäº‹ä»¶ä»¥ç¡®ä¿æ‰‹æœºç«¯é‡Šæ”¾æ—¶æ›´æ–°
        range.addEventListener('touchend', function() {
          updatePreview();
        }, { passive: true });
      });
      
      // é¢œè‰²é€‰æ‹©å™¨ç«‹å³æ›´æ–°
      const colorInputs = document.querySelectorAll('input[type="color"]');
      colorInputs.forEach(input => {
        input.addEventListener('change', function() {
          updatePreview();
        });
        
        // æ‰‹æœºç«¯åœ¨æ‹–åŠ¨æ—¶ä¹Ÿå®æ—¶æ›´æ–°
        input.addEventListener('input', function() {
          triggerPreviewUpdate();
        });
      });
    });
  </script>
</body>
</html>
